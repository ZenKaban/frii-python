[
{"Слайды курса «Технологии и разработка СУБД»": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/webt/mu/o9/wb/muo9wbacmeq-rlwlbxxm_6g36gk.jpeg\"><br>\r\n<br>\r\nНа протяжении последнего года моя коллега <a href=\"https://habr.com/users/lubennikovaav/\">Анастасия Лубенникова</a> и я вели курс под названием «Технологии и разработка СУБД». Данный курс посвящен разработке реляционных СУБД с акцентом на конкретную реализацию в лице PostgreSQL. Мы сотрудничали сразу с несколькими ВУЗами. На <a href=\"https://www.hse.ru/\">ВШЭ</a> это был обязательный предмет, рассчитанный на студентов 4-го курса (на фото студенты сдают экзамен). В <a href=\"https://cs.msu.ru/\">ВМК МГУ</a> это был предмет по выбору, на который ходили студенты разных курсов. <a name=\"habracut\"></a><br>\r\n<br>\r\nТак как учебный процесс в названных ВУЗах немного различается (система оценок, модули против семестров и т.д.) нам приходилось адаптировать курс. Ниже представлена его полная программа, включающая все, что было прочитано в обоих ВУЗах, со всеми последними исправлениями:<br>\r\n<br>\r\n<ul>\r\n<li><a href=\"https://docs.google.com/presentation/d/1cFfxD6qp_fsF1vMC58U5Sy24bg15C7sv3Qg-chonnoI/edit#slide=id.p\">Лекция 1. Введение</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/15v4PyIJ84wdG8AT9FMHpPjYZ0vmFwA0mbERIUBFmbDU/edit#slide=id.p\">Лекция 2. Обзор архитектуры</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1tjTOMPq0uWoS0E-AuBVdw-I14Z3NI1_HJGcPFT1FzKM/edit#slide=id.p\">Лекция 3. Хранение данных на диске</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/17uaEpB0yygDOQkvQuD3MltScuR-ZT-fIr7lZmRnNIbQ/edit#slide=id.p\">Лекция 4. Методы доступа</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1qUS3WuCxn6PS2bh6Vl1lCe9_ybdN689Sgl_iGJqwGUA/edit#slide=id.p\">Лекция 5. Практический C/C++</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/19-xgp_p43mX9z1IO3QTJVMFvMMSm3Bu07hVwTMRxgW8/edit#slide=id.p\">Лекция 6. Журнал транзакций</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1amry2cQRZyR-MOed5Bj1Jbm4Ane_mPmLc9x9kxjfMBE/edit#slide=id.p\">Лекция 7. Репликация в PostgreSQL</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1NTFENJ8wAcU4QS3AbbXfmj1xfpMLAM2JylMOS-FVlW4/edit#slide=id.p\">Лекция 8. Изоляция транзакций</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1XnhlPU11nXdedBe6sdqldOpYe1X2ZdQM2g_aqJfGr0Y/edit#slide=id.p\">Лекция 9. MVCC &amp; Snapshot Isolation</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1FUz2vR3I-NaxLFqzTNWIah67GJNb0dOgx8qGcVjyyaM/edit#slide=id.g287f6f40de_0_0\">Лекция 10. Полнотекстовый поиск в PostgreSQL</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1vUmpr3bDwlwiygXUAfPkbzTc292fMI23W86zsI_6RRg/edit#slide=id.p\">Лекция 11. Поиск по геоданным с PostGIS</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1ACA4W4tVLWKEbnzU51v8viXky-FR37LcdA2a7UUQwr4/edit#slide=id.p\">Лекция 12. Выполнение запросов</a>;</li>\r\n<li><a href=\"https://docs.google.com/presentation/d/1rhkMGe3KI6H1hSIF-yAZInr5Sxviml3uYw2eMoXDRfI/edit#slide=id.p\">Лекция 13. Введение в распределенные системы</a>;</li>\r\n</ul><br>\r\nКаталог на Google Drive с лекциями находится <a href=\"https://drive.google.com/drive/folders/15Kx1OG3ErPrMosZkF4YmD0Im2cj2T4dr\">здесь</a>. ZIP-архив со всеми лекциями в формате PDF можно скачать <a href=\"https://github.com/afiskon/dbmsdev-final/raw/master/dbmsdev-final.zip\">отсюда (4.4 Мб)</a>. Также отдельные PDF-файлы <a href=\"https://github.com/afiskon/dbmsdev-final\">доступны на GitHub</a>. Что касается вопроса лицензии, то вы можете свободно распространять и модифицировать слайды, а также читать по ним курсы, главное не присваивайте себе авторство. Вообще, если кто-то решит читать курс по нашим слайдам, мы будем только рады, и с удовольствием поможем с подготовкой.<br>\r\n<br>\r\nПредвидя появление закономерного вопроса в комментариях, отмечу, что на данный момент мы решили немного отдохнуть от ведения курсов. Дело это оказалось весьма трудоемким, даже учитывая, что теперь-то у нас есть все материалы курса. Однако если вы интересуетесь разработкой баз данных, можете присоединиться к Telegram-каналу <a href=\"https://t.me/dbmsdev\">@dbmsdev</a>, который был создан для связи с нашими студентами. Там мы с радостью ответим на вопросы как по данному курсу, так и по разработке СУБД вообще (насколько это позволяет наш скромный опыт).<br>\r\n<br>\r\nВ заключение у меня для вас небольшой fun fact. Если вам кажется, что вы что-то не до конца понимаете в какой-то предметной области, лучший способ разобраться — это начать вести соответствующий курс :)</div>"]},
{"Примеры реальных патчей в PostgreSQL: часть 2 из N": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/files/1ef/102/ef2/1ef102ef2c034df1a4f039a897758206.png\"><br>\r\n<br>\r\nВ предыдущих статьях мы <a href=\"https://habrahabr.ru/company/postgrespro/blog/308442/\">рассмотрели процесс разработки PostgreSQL</a>, а также <a href=\"https://habrahabr.ru/company/postgrespro/blog/309488/\">примеры некоторых реальных патчей</a>, принятых в эту РСУБД за последнее время. При этом рассмотренные патчи были, прямо скажем, какие-то «несерьезные» — исправление опечаток, исправление простейших косяков, найденных при помощи статического анализа, и прочее в таком духе.<br>\r\n<br>\r\nСегодня мы рассмотрим примеры уже более серьезных патчей, устраняющих узкие места в коде, исправляющих достаточно серьезные баги, относительно крупные рефакторинги, и так далее. Как и ранее, основная цель статьи — не столько осветить изменения, принятые в PostgreSQL 9.6, сколько показать, что разработка open source проектов, в частности PostgreSQL, это интересно и не так сложно, как вам это может казаться.<br>\r\n<br>\r\nЕсли эта тема вам интересна, прошу под кат.<br>\r\n<a name=\"habracut\"></a><br>\r\n<h3>6. Ускорение ResourceOwner'а для большого количества ресурсов</h3><br>\r\nResourceOwner — это объект (насколько слово «объект» применимо для процедурного языка C), предназначенный для управления ресурсами в процессе выполнения SQL-запросов. На каждую транзакцию и субтранзакцию создается отдельный ResourceOwner. ResourceOwner имеет множество методов вроде RememberLock / ForgetLock, RememberFile / ForgetFile и подобных. Кроме того, ResourceOwner'ы можно выстраивать в иерархии. В случае отката транзакции в силу любой причины (пользователь сказал rollback, возникла исключительная ситуация, и т.д.) мы просто освобождаем ResourceOwner, а это освобождение в свою очередь приводит к освобождению всех занятых ресурсов как в данном ResourceOwner'е, так и в его «детях». Подробности можно найти в <a href=\"https://github.com/postgres/postgres/blob/REL9_5_STABLE/src/backend/utils/resowner/README\">соответствующем файле README</a>.<br>\r\n<br>\r\nВ 9.5 для хранения ресурсов ResourceOwner использовал массивы. При этом предполагалось, что ресурсы обычно освобождаются в порядке обратном тому, в котором они выделялись, поэтому методы Forget* искали ресурсы с конца массива. На практике, однако, оказалось, что этот подход не всегда хорошо работает. Так <a href=\"https://eax.me/c-cpp-profiling/\">профайлинг показал</a>, что при выполнении простейших SELECT-запросов к таблице с <a href=\"https://habrahabr.ru/post/273933/\">большим количеством партиций</a> при таком подходе PostgreSQL проводит 30% всего времени в этих самых Forget* методах.<br>\r\n<br>\r\nУстранить bottleneck удалось, заменив массивы на хэш-таблицы. При этом, если количество ресурсов в ResourceOwner'е невелико, то используются массивы, как и раньше:<br>\r\n<br>\r\n<pre><code class=\"cpp\">/*\n * ResourceArray is a common structure for storing all types of resource IDs.\n *\n * We manage small sets of resource IDs by keeping them in a simple array:\n * itemsarr[k] holds an ID, for 0 &lt;= k &lt; nitems &lt;= maxitems = capacity.\n *\n * If a set grows large, we switch over to using open-addressing hashing.\n * Then, itemsarr[] is a hash table of \"capacity\" slots, with each\n * slot holding either an ID or \"invalidval\".  nitems is the number of valid\n * items present; if it would exceed maxitems, we enlarge the array and\n * re-hash.  In this mode, maxitems should be rather less than capacity so\n * that we don't waste too much time searching for empty slots.\n *\n * In either mode, lastidx remembers the location of the last item inserted\n * or returned by GetAny; this speeds up searches in ResourceArrayRemove.\n */\ntypedef struct ResourceArray\n{\n    Datum      *itemsarr;       /* buffer for storing values */\n    Datum       invalidval;     /* value that is considered invalid */\n    uint32      capacity;       /* allocated length of itemsarr[] */\n    uint32      nitems;         /* how many items are stored in items array */\n    uint32      maxitems;       /* current limit on nitems before enlarging */\n    uint32      lastidx;        /* index of last item returned by GetAny */\n} ResourceArray;\n</code></pre><br>\r\nЭтот же патч включает в себя рефакторинг ResourceOwner. Раньше для каждого типа ресурсов использовался отдельный массив File'ов, HeapTuple'ов и так далее. Все эти типы являются либо указателями, либо целыми числами, и потому могут быть сохранены в Datum (местный аналог uintptr_t). Была введена новая сущность ResourceArray, позволяющая хранить любые ресурсы, что избавило от существенного количества дублированного кода.<br>\r\n<br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=cc988fbb0bf60a83b628b5615e6bade5ae9ae6f4;hp=879d71393de001880e031\">cc988fbb0bf60a83b628b5615e6bade5ae9ae6f4</a><br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20151204151504.5c7e4278@fujitsu#20151204151504.5c7e4278@fujitsu\">20151204151504.5c7e4278@fujitsu</a><br>\r\n<br>\r\n<h3>7. Партицирование freelist'а для разделяемого dynahash</h3><br>\r\nDynahash (см <a href=\"https://github.com/postgres/postgres/blob/REL9_5_STABLE/src/backend/utils/hash/dynahash.c\">файл dynahash.c</a>) — это местная реализация хэш-таблиц. Хэш-таблицы в PostgreSQL могут вести себя сильно по-разному в зависимости от флагов, с которыми они были созданы. Например, они могут жить как в локальной памяти процесса, так и в <a href=\"https://www.freebsd.org/cgi/man.cgi?query=shmget\">разделямой памяти</a>. В случае использования последней разделяемая память отображается на одни и те же виртуальные адреса во всех процессах PostgreSQL. Выделяется разделяемая память один раз и количество этой памяти не может быть изменено в процессе работы РСУБД.<br>\r\n<br>\r\nВ силу этих причин для отслеживания свободной памяти в разделяемых хэш-таблицах используется так называемый freelist — список свободных кусков памяти небольшого размера. При освобождении памяти она добавляется во freelist. Когда нужно выделить память, она берется из freelist'а. Так как доступ к разделяемой хэш-таблице осуществляется сразу несколькими процессами, доступ к freelist синхронизируется с помощью спинлока. Выяснилось, что определенных нагрузках возникает lock contention за этот спинлок.<br>\r\n<br>\r\nПринятый в итоге патч решает эту проблему следующим образом. Вместо одного freelist'а используется несколько (32), каждый со своим спинлоком.<br>\r\n<br>\r\nБыло:<br>\r\n<br>\r\n<pre><code class=\"cpp\"> struct HASHHDR\n {\n    slock_t     mutex;          /* unused if not partitioned table */\n    long        nentries;       /* number of entries in hash table */\n    HASHELEMENT *freeList;      /* linked list of free elements */\n\n/* ... */\n</code></pre><br>\r\nСтало:<br>\r\n<br>\r\n<pre><code class=\"cpp\">#define NUM_FREELISTS          32\n\ntypedef struct\n{\n   slock_t     mutex;          /* spinlock */\n   long        nentries;       /* number of entries */\n   HASHELEMENT *freeList;      /* list of free elements */\n}  FreeListData;\n\n struct HASHHDR\n {\n    FreeListData freeList[NUM_FREELISTS];\n\n/* ... */\n</code></pre><br>\r\nПо умолчанию для выделения памяти используется freelist, номер которого определяется по младшим битам хэш-значения от ключа:<br>\r\n<br>\r\n<pre><code class=\"cpp\">#define FREELIST_IDX(hctl, hashcode) \\\n   (IS_PARTITIONED(hctl) ? hashcode % NUM_FREELISTS : 0)\n</code></pre><br>\r\nОднако если память в «нашем» freelist'е закончилась, она «заимствуется» из других freelist'ов.<br>\r\n<br>\r\nПомимо прочего, патч интересен тем, что перед его принятием мне пришлось написать около 15-и его версий, фактически перебрав все возможные стратегии шардирования freelist'ов, их количество, и прочие параметры, выбрав один вариант, показавший наилучшую производительность. Например, вместо 32-х спинлоков, используемых в окончательной реализации, можно было бы использовать один RWLock, захватываемый на чтение, если мы хотим взять память из «нашего» freelist'а, и на запись — если позаимствовать из других. Плюс спинлоки можно по-разному расположить в памяти, с выравниванием или без выравнивания по размеру кэшлайна, и так далее. <br>\r\n<br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=44ca4022f3f9297bab5cbffdd97973dbba1879ed;hp=ea4b8bd6188ecb17ba37d\">44ca4022f3f9297bab5cbffdd97973dbba1879ed</a><br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20151211170001.78ded9d7@fujitsu#20151211170001.78ded9d7@fujitsu\">20151211170001.78ded9d7@fujitsu</a><br>\r\n<br>\r\n<h3>8. Поддержка нескольких итераторов в RB-деревьях</h3><br>\r\nРаботая над очередной фичей, я заметил, что интерфейс итерации по красно-черным деревьям (на данный момент они используются исключительно в GIN-индексах) в PostgreSQL выглядит следующим образом:<br>\r\n<br>\r\n<pre><code class=\"cpp\">void rb_begin_iterate(RBTree *rb, RBOrderControl ctrl);\nRBNode *rb_iterate(RBTree *rb);\n</code></pre><br>\r\nМожно заметить, что этот интерфейс не позволяет создавать больше одного итератора по дереву, что довольно неудобно. Более того, реализация была весьма странной. Например, она хранила состояние итерации в узлах дерева.<br>\r\n<br>\r\nПодумав немного, я переписал все это хозяйство, после чего интерфейс получился следующим:<br>\r\n<br>\r\n<pre><code class=\"cpp\">void rb_begin_iterate(RBTree *rb, RBOrderControl ctrl, RBTreeIterator *iter);\nRBNode *rb_iterate(RBTreeIterator *iter);\n</code></pre><br>\r\nУзнать больше о различных контейнерах, используемых в PostgreSQL, вы можете из статьи <a href=\"https://eax.me/c-lists-rbtree/\">Не унылый пост о списках и деревьях поиска в языке C</a>. Кроме того, вас может заинтересовать <a href=\"https://github.com/afiskon/c-algorithms\">GitHub-репозиторий</a>, созданный мной в процессе работы над этой задачей. В нем вы найдете реализацию одно- и двусвязных списков, красно-черных деревьев и хэш-таблиц на языке C. Библиотека обильно покрыта тестами и распространяется под лицензией MIT/BSD.<br>\r\n<br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=9f85784cae4d057f307b83b0d33edede33434f04;hp=76f9dd4fa82270899f7b5\">9f85784cae4d057f307b83b0d33edede33434f04</a><br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20160727172645.3180b2e0@fujitsu#20160727172645.3180b2e0@fujitsu\">20160727172645.3180b2e0@fujitsu</a><br>\r\n<br>\r\n<h3>9. Исправление валидации чексумм в pg_filedump для таблиц с несколькими сегментами</h3><br>\r\nPostgreSQL хранит данные таблиц и индексов в так называемых страницах. Размер одной страницы по умолчанию равен 8 Кб. Страницы хранятся в файлах на диске, называемых сегментами. Размер одного сегмента по умолчанию равен 1 Гб. Нарезание отношений и индексов на сегменты позволяет PostgreSQL работать даже на файловой системе, не поддерживающей файлы размером более 1 Гб. При помощи страниц реализуется кэширование часто используемых данных в памяти так называемым buffer manager'ом, что существенно сокращает количество обращений к диску. <br>\r\n<br>\r\nУтилита pg_filedump позволяет делать разные полезные вещи с сегментами и страницами. Например, она может проверить чексуммы всех страниц в сегменте. Чексуммы пишутся в страницы, если база данных была создана путем вызова initdb с флагом -k:<br>\r\n<br>\r\n<pre><code>  -k, --data-checksums      use data page checksums\n</code></pre><br>\r\nИнтересно, что процедура pg_checksum_page, вычисляющая хэш-функцию страницы, зависит не только от содержимого страницы, но и от номера блока:<br>\r\n<br>\r\n<pre><code class=\"cpp\">uint16 pg_checksum_page(char *page, BlockNumber blkno)\n</code></pre><br>\r\nЭто позволяет убедиться, что страница не только хранит правильные данные, но и записана по правильному смещению в сегменте.<br>\r\n<br>\r\nТак вот, недавно в pg_filedump был обнаружен такой баг. Чексуммы правильно проверялись для нулевого сегмента, но для первого, второго и так далее сегментов чексуммы, считаемые pg_filedump, не сходились с теми, что посчитал сам PostgreSQL. Как выяснилось, для любого сегмента pg_filedump начинал считать номера блоков с нуля. Правильный же способ заключается в том, чтобы учитывать все предыдущие сегменты, и использовать для данного сегмента «абсолютные» номера блогов, а не «относительные».<br>\r\n<br>\r\nВ силу понятных причин, в этом же патче в pg_filedump была добавлена поддержка двух ранее отсутствовавших флагов:<br>\r\n<br>\r\n<pre><code>  -s  Force segment size to [segsize]\n  -n  Force segment number to [segnumber]\n</code></pre><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commitdiff;h=052ed0112967dd1e9b0e2cbe54821c04475f1a3a;hp=b163cdaa53b651958cc8\">052ed0112967dd1e9b0e2cbe54821c04475f1a3a</a><br>\r\nОбсуждение: <i>(исключительно offlist)</i><br>\r\n<br>\r\n<h3>10. Проверка значения, возвращаемого процедурами malloc(), realloc() и прочими</h3><br>\r\nНапоследок я решил оставить патч, написанный не мной, но для которого я выступал в качестве reviewer'а. В процессе code review мною было предложено немало улучшений для данного патча.<br>\r\n<br>\r\nMichael Paquier обратил внимание на то, что в ряде мест PostgreSQL не проверяет коды возврата процедур malloc(), realloc() и strdup(). В ходе работы над патчем список процедур был дополнен calloc(), а также процедурами для работы с разделяемой памятью.<br>\r\n<br>\r\nВ результате там, где это возможно, вызовы были заменены на аналогичные безопасные PostgreSQL-аналоги — pg_strdup, pg_malloc и прочие:<br>\r\n<br>\r\n<pre><code class=\"diff\">-   steps = malloc(sizeof(Step *) * nsteps);\n+   steps = pg_malloc(sizeof(Step *) * nsteps);\n</code></pre><br>\r\nВ остальных местах были просто добавлены проверки:<br>\r\n<br>\r\n<pre><code class=\"diff\">        new_environ = (char **) malloc((i + 1) * sizeof(char *));\n+       if (!new_environ)\n+       {\n+           write_stderr(\"out of memory\\n\");\n+           exit(1);\n+       }\n</code></pre><br>\r\nСм также пост самого Michael — <a href=\"http://paquier.xyz/postgresql-2/postgres-10-highlight-shmem-alloc/\">Postgres 10 highlight — ShmemAlloc and ShmemAllocNoError</a>.<br>\r\n<br>\r\nКоммиты: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=052cc223d5ce1b727f62afff75797c88d82f880b;hp=9daec77e165de461fca9d\">052cc223</a>, <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=6c03d981a6b64ed8caaed4e94b54ef926202c9f3;hp=6f7c0ea32f808a7dad3ec\">6c03d981</a><br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/CAB7nPqRu07Ot6iht9i9KRfYLpDaF2ZuUv5y_+72uP23ZAGysRg@mail.gmail.com#CAB7nPqRu07Ot6iht9i9KRfYLpDaF2ZuUv5y_+72uP23ZAGysRg@mail.gmail.com\">CAB7nPqRu07Ot6iht9i9KRfYLpDaF2ZuUv5y_+72uP23ZAGysRg@mail.gmail.com</a><br>\r\n<br>\r\n<h3>Продолжение следует...</h3><br>\r\nКонечно, при условии, что подобного рода посты представляют для кого-то интерес :) Возможно, мне также удастся уговорить кого-нибудь из коллег осветить патчи, над которыми они работали в последнее время. Ведь кто сможет рассказать о патче лучше самого разработчика этого патча?<br>\r\n<br>\r\nКак всегда, я с нетерпением жду ваших вопросов, и буду рад ответить на них в комментариях. И вообще, не стесняйтесь оставлять любые комментарии и дополнения!<br>\r\n<br>\r\nПродолжение: <a href=\"https://habrahabr.ru/company/postgrespro/blog/325850/\">Примеры реальных патчей в PostgreSQL: часть 3 из N</a></div>"]},
{"Контрибьютим в PostgreSQL: примеры реальных патчей, часть 1 из N": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/files/c0a/2b3/b47/c0a2b3b47dbe4bce8a31b7aa10980f6e.png\"><br>\r\n<br>\r\nРанее в статье <a href=\"https://habrahabr.ru/company/postgrespro/blog/308442/\">Становимся контрибьютером в PostgreSQL</a> был подробно рассмотрен процесс разработки PostgreSQL и используемые при этом инструменты, были предложены некоторые идеи для первого патча и рассказано, куда и как эти патчи нужно посылать. Также были приведены ссылки на дополнительные источники информации касательно внутреннего устройства РСУБД.<br>\r\n<br>\r\nТеперь же мы рассмотрим примеры реальных патчей, принятых в PostgreSQL за последнее время. Какие-то из этих патчей были написаны непосредственно мной, при разработке других я активно участвовал в качестве ревьювера. Это сравнительно небольшие патчи. На момент написания этих строк я занимаюсь разработкой PostgreSQL менее года, и ранее разработкой СУБД я не занимался (ровно как и разработкой на языке C за деньги). Поэтому есть основания полагать, что данные патчи будут интересны новичкам, желающим начать участвовать в разработке открытых проектов, притом не обязательно именно PostgreSQL. Чтобы не писать лонгридов, статья разбита на части.<br>\r\n<br>\r\nЗаинтересовавшихся прошу проследовать под кат. <a name=\"habracut\"></a><br>\r\n<br>\r\n<h3>1. Удаление дублированного кода в ReorderBufferCleanupTXN()</h3><br>\r\nМне нравится время от времени проходиться по коду PostgreSQL <a href=\"https://eax.me/c-static-analysis/\">разными статическими анализаторами</a>, особенно Clang Static Analyzer. Часто эти анализаторы ругаются на какую-то сомнительную ерунду, но среди этой ерунды иногда можно найти действительно очень подозрительные куски кода. Один из таких кусков выглядел следующим образом:<br>\r\n<br>\r\n<pre><code class=\"cs\">/* delete from list of known subxacts */\nif (txn-&gt;is_known_as_subxact)\n{\n    /* NB: nsubxacts count of parent will be too high now */\n    dlist_delete(&amp;txn-&gt;node);\n}\n/* delete from LSN ordered list of toplevel TXNs */\nelse\n{\n    dlist_delete(&amp;txn-&gt;node);\n}\n</code></pre><br>\r\nСогласитесь, довольно странно делать в блоках if и else одно и то же. После короткого обсуждения этой проблемы в рассылке и всего лишь одного переписывания патча код превратился в:<br>\r\n<br>\r\n<pre><code class=\"cpp\">/*\n * Remove TXN from its containing list.\n *\n * Note: if txn-&gt;is_known_as_subxact, we are deleting the TXN from its\n * parent's list of known subxacts; this leaves the parent's nsubxacts\n * count too high, but we don't care.  Otherwise, we are deleting the TXN\n * from the LSN-ordered list of toplevel TXNs.\n */\ndlist_delete(&amp;txn-&gt;node);\n</code></pre><br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20160404190345.54d84ee8@fujitsu#20160404190345.54d84ee8@fujitsu\">20160404190345.54d84ee8@fujitsu</a><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=b6182081be4a795d70b966be2542ad32d1ffbc20;hp=c7f68bea22bf680a4eab4b8b1592b3c90bc634ac\">b6182081be4a795d70b966be2542ad32d1ffbc20</a><br>\r\n<br>\r\n<h3>2. Исправление двойной инициализации переменных</h3><br>\r\nЧестно говоря, я уже не помню, была ли эта проблема найдена глазами, или же статическим анализатором. В нескольких местах был обнаружен код в стиле:<br>\r\n<br>\r\n<pre><code class=\"cpp\">char\t   *qual_value;\nParseState *qual_pstate = make_parsestate(NULL);\n\n/* parsestate is built just to build the range table */\nqual_pstate = make_parsestate(NULL);\n</code></pre><br>\r\nКак видите, переменная инициализируется дважды, только напрасно грея процессор. Патч был принят моментально без особых вопросов.<br>\r\n<br>\r\nОбсуждание: <a href=\"https://www.postgresql.org/message-id/flat/20160316112019.64057481%40fujitsu#20160316112019.64057481@fujitsu\">20160316112019.64057481@fujitsu</a><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=bd0ab28912d7502b237b8aeb95d052abe4ff6bc6;hp=c27033ff7c17b5100d02c454a0eebb95ec7b91cc\">bd0ab28912d7502b237b8aeb95d052abe4ff6bc6</a><br>\r\n<br>\r\n<h3>3. Исправление опечаток в комментариях</h3><br>\r\nВ любом достаточно крупном проекте присутствует изрядное количество опечаток. Найти их очень просто, включив проверку орфографии в вашей IDE или текстовом редакторе. Я лично <a href=\"https://eax.me/vim-commands/\">пишу код в Vim</a>. Для проверки орфографии в ~/.vimrc у меня есть строчки:<br>\r\n<br>\r\n<pre><code>command! SpellOn :set spell spelllang=en_us,ru_ru\ncommand! SpellOff :set nospell\n</code></pre><br>\r\nЕсли кому-то интересно, то полная версия моего ~/.vimrc, ровно как и всех остальных конфигурационных файлов, <a href=\"https://github.com/afiskon/freebsd-on-desktop-v2/tree/master/home/eax\">доступны здесь</a>.<br>\r\n<br>\r\nНередко опечатки появляются по той причине, что перед принятием патчей коммиттеры немного, совсем чуть-чуть, переписывают их. В результате получается совершенно новый код, который никто до этого не вычитывал. Можно каждую неделю слать несколько патчей, просто внимательно вычитывая новые коммиты и находя в них опечатки!<br>\r\n<br>\r\nОбсуждение: <i>(что-то не удается найти)</i><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=2d8a1e22b109680204cb015a30e5a733a233ed64;hp=aa698d753566f68bdd54881d30b1a515b0327b0e\">2d8a1e22b109680204cb015a30e5a733a233ed64</a><br>\r\n<br>\r\n<h3>4. Исправление двух идентичных комментариев</h3><br>\r\nПомимо опечаток в комментариях встречаются и другие виды ошибок. Например, в результате <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git&amp;a=commitdiff&amp;h=b6fb6471f6afaf649e52f38269fd8c5c60647669\">коммита b6fb6471</a> был добавлен такой кусок кода:<br>\r\n<br>\r\n<pre><code class=\"cpp\">/*-----------\n * pgstat_progress_update_param() -\n *\n * Update index'th member in st_progress_param[] of own backend entry.\n *-----------\n */\nvoid\npgstat_progress_update_param(int index, int64 val)\n{\n   volatile PgBackendStatus *beentry = MyBEEntry;\n\n   Assert(index &gt;= 0 &amp;&amp; index &lt; PGSTAT_NUM_PROGRESS_PARAM);\n\n   if (!beentry || !pgstat_track_activities)\n       return;\n\n   pgstat_increment_changecount_before(beentry);\n   beentry-&gt;st_progress_param[index] = val;\n   pgstat_increment_changecount_after(beentry);\n}\n\n/*-----------\n * pgstat_progress_end_command() -\n *\n * Update index'th member in st_progress_param[] of own backend entry.\n *-----------\n */\nvoid\npgstat_progress_end_command(void)\n{\n</code></pre><br>\r\nМожно заметить, что две разные процедуры имеют совершенно одинаковое описание, что явно какой-то косяк.<br>\r\n<br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20160310120506.5007ea28%40fujitsu#20160310120506.5007ea28@fujitsu\">20160310120506.5007ea28@fujitsu</a><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=090b287fc59e7a44da8c3e0823eecdc8ea4522f2;hp=cc402116ca156babcd3ef941317f462a96277e3a\">090b287fc59e7a44da8c3e0823eecdc8ea4522f2</a><br>\r\n<br>\r\n<h3>5. Ворнинги при компиляции на FreeBSD</h3><br>\r\nБольшинство разработчиков PostgreSQL сидят под MacOS и Linux. Поэтому бывает полезно попытаться собрать проект на экзотике типа Microsoft Windows :) или FreeBSD. Используя этот прием, мне, например, удалось обнаружить, что PostgreSQL на FreeBSD собирается со следующими warning'ами:<br>\r\n<br>\r\n<pre><code>pg_locale.c:1290:12: warning: implicit declaration of function\n'wcstombs_l' is invalid in C99 [-Wimplicit-function-declaration]\n\nresult = wcstombs_l(to, from, tolen, locale);\n\npg_locale.c:1365:13: warning: implicit declaration of function\n'mbstowcs_l' is invalid in C99 [-Wimplicit-function-declaration]\n\nresult = mbstowcs_l(to, str, tolen, locale);\n\n2 warnings generated.</code></pre><br>\r\nИсправить эту проблему оказалось не слишком сложно, хотя и потребовало <a href=\"https://eax.me/autotools/\">повозиться с Autotools</a>, что, по моему опыту, обычно не очень приятное занятие.<br>\r\n<br>\r\nОбсуждение: <a href=\"https://www.postgresql.org/message-id/flat/20160310163632.53d8e2cc%40fujitsu#20160310163632.53d8e2cc@fujitsu\">20160310163632.53d8e2cc@fujitsu</a><br>\r\nКоммит: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=0e9b89986b7ced6daffdf14638a25a35c45423ff;hp=101fd9349eddb7e9ed84a239145d5230a9bc7336\">0e9b89986b7ced6daffdf14638a25a35c45423ff</a><br>\r\n<br>\r\n<h3>Продолжение следует...</h3><br>\r\nКак видите, чтобы начать контрибьютить в PostgreSQL, не требуется глубокого знания устройства реляционных баз данных или десяти лет опыта программирования на языке C. По большому счету, стать контрибьютором может любой человек, в теории — даже не умеющий программировать вообще. В этой части были рассмотрены, пожалуй, самые тривиальные патчи. В следующий раз мы рассмотрим патчи поинтереснее, решающие проблему lock contention, уменьшающие сложность алгоритма с O(N) до O(1), реализующие обход бинарных деревьев, чинящие утечки ресурсов, и не только.<br>\r\n<br>\r\nКак всегда, я буду рад любым вашим комментариям и вопросам!<br>\r\n<br>\r\nПродолжение: <a href=\"https://habrahabr.ru/company/postgrespro/blog/310372/\">Примеры реальных патчей в PostgreSQL: часть 2 из N</a></div>"]},
{"Становимся контрибьютером в PostgreSQL": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/getpro/habr/post_images/3ea/847/61b/3ea84761b897d0af5304dc43caca1249.png\" alt=\"PostgreSQL Logo\" align=\"right\"> В этой статье я хотел бы рассказать о том, как выглядит процесс разработки PostgreSQL глазами одного из контрибьютеров в этот самый PostgreSQL. Заниматься разработкой этой СУБД я начал в декабре 2015 года, когда устроился работать в компанию Postgres Professional. То есть, не так уж давно. А значит, еще свежи воспоминания о моментах, которые поначалу казались мне не вполне очевидными. Хотелось бы их законспектировать, чтобы новым людям, приходящим в нашу команду, а также всем тем, кто желает попробовать себя в роли разработчика открытой реляционной СУБД, было легче. Я расскажу о том, как выглядит процесс разработки PostgreSQL, какие инструменты я использую в своей повседневной работе, как следует оформлять патчи, и так далее. Заинтересовавшихся прошу проследовать под кат.<br>\r\n<a name=\"habracut\"></a><br>\r\n<h3>Набор инструментов</h3><br>\r\nВопрос, который будоражит умы миллионов — какую IDE или текстовый редактор использовать? :) Практика показывает, что разрабатывать PostgreSQL можно в чем угодно. Кто-то из моих коллег использует Sublime Text, кто-то предпочитает Vim, кто-то Emacs, также есть пользователи KDevelop и Visual Studio Code. Я лично первое время вполне успешно использовал CLion, сейчас же перешел на Vim + ctags. В общем и целом, главное, чтобы в редакторе была подсветка синтаксиса, переход к определению, возможно какие-то простые вещи вроде переименования переменных и проверки орфографии. Какие-то навороченные автоматические рафакторинги вам вряд ли понадобятся. Дело в том, что патч с результатом таких рефакторингов вряд ли так просто примут.<br>\r\n<br>\r\nВторой не менее волнительный вопрос — какую ОС или дистрибутив Linux выбрать? У нас в компании многие разработчики используют Ubuntu. Также есть пользователи MacOS. Под Windows, вроде, никто не сидит — для разработки под эту платформу обычно запускают виртуалку. Есть один пользователь Arch Linux. Я лично долгое время пользовался Ubuntu, но недавно ударился головой и перешел на FreeBSD. В общем и целом, любая *nix система должна подойти.<br>\r\n<br>\r\nPostgreSQL успешно компилируется GCC, CLang и Visual Studio, возможно и какими-то другими компиляторами (Intel C++ Compiler?). Более того, сообщество стремится поддерживать совместимость кода со всеми этими компиляторами. Так что компилятор вы можете использовать любой. Также вы можете использовать свой любимый отладчик, будь то GDB, LLDB, что-то встроенное в вашу IDE или какой-нибудь WinDbg.<br>\r\n<br>\r\nКод PostgreSQL <a href=\"https://git.postgresql.org/gitweb/\">живет в Git</a>. Помимо официального репозитория еще есть <a href=\"https://github.com/postgres/postgres\">зеркало на GitHub</a>, но это чисто зеркало. Открывать там issues и слать туда пуллреквесты бессмысленно. Во время разработки патча никому нет дела, какую систему контроля версий вы используете. Но патч обычно посылают в виде вывода команды git diff.<br>\r\n<br>\r\nВ первом приближении, вроде, ничего не забыл. Время от времени я также использую perf, tcpdump, strace/truss, dtrace, rr, lcov, различные статические анализаторы и другие инструменты. Но потребность в них возникает скорее в порядке исключения. Основные инструменты разработки — это текстовый редактор, git, компилятор, отладчик и, конечно же, мозг. Да, и еще почтовый клиент. Но об этом я расскажу ниже.<br>\r\n<br>\r\n<h3>Сборка, прогон тестов и так далее</h3><br>\r\nВ настоящее время PostgreSQL использует Autotools. Autotools сам по себе не очень приятная штука. К тому же, не рассчитанная на Windows. Поэтому для сборки PostgreSQL под эту платформу предусмотрен специальный набор Perl-скриптов, что несколько костыльно. Мой коллега <a href=\"https://github.com/stalkerg\">Юрий Журавлев</a> пытается протолкнуть патч, <a href=\"https://github.com/stalkerg/postgres_cmake\">переводящий PostgreSQL на CMake</a>. Но там все непросто, так как текущая система расширений PostgreSQL сильно завязана на Autotools.<br>\r\n<br>\r\nВсе проекты, использующие Autotools, собираются примерно одинаково:<br>\r\n<br>\r\n<pre><code class=\"bash\">./configure --prefix=...\nmake -j4 -s\nmake check\nmake install\n</code></pre><br>\r\nДля быстрого локального развертывания PostgreSQL я использую <a href=\"https://github.com/afiskon/pgscripts\">такой набор скриптов</a>, многими из которых со мной поделился <a href=\"https://github.com/kelvich\">Стас Кельвич</a>.<br>\r\n<br>\r\nТонкий момент, на который налетают все начинающие контрибьюторы в PostgreSQL без исключения — если вы внесли изменение в .h файл, не забудьте прогнать make clean. По умолчанию при изменении .h файла зависящие от него .c файлы не пересобираются. Если этого не знать, можно пронаблюдать широчайший спектр занимательнейших магических эффектов :)<br>\r\n<br>\r\n<h3>Идея для первого патча, и как еще можно помочь проекту</h3><br>\r\nЧасто человека, находящегося в поисках идеи для патча, отправляют к <a href=\"https://wiki.postgresql.org/wiki/Todo\">списку TODO</a>. На мой взгляд, это довольно вредный совет, по целому ряду причин. Во-первых, этот список не всегда находится в актуальном состоянии. Во-вторых, там есть пункты, про которые никто точно не знает, как их правильно сделать, и потому было решено просто добавить пункт в TODO, авось когда-нибудь придет прозрение. Наконец, в третьих, большинство задач из этого списка довольно сложны. Я бы советовал начать с чего-то попроще.<br>\r\n<br>\r\nПроще всего поискать в коде и документации опечатки. Их там действительно много. Так происходит по той причине, что перед мержем предложенных патчей коммитеры часто их слегка переписывают, совсем чуть-чуть. В результате получается совершенно новый патч, который никто не вычитывал, отсюда и опечатки. Можно просто следить за новыми коммитами и каждую неделю присылать 1-2 патча. Исправлением комментариев к коду сложно что-то сломать, поэтому ваш патч охотно примут.<br>\r\n<br>\r\nБывает так, что какие-то куски кода можно немного отрефакторить. Это тоже довольно простое изменение. Делаем код красивее и правильнее, прогоняем тесты, если ничего не сломалось — предлагаем патч.<br>\r\n<br>\r\nИсправление багов. В рассылку <a href=\"https://www.postgresql.org/list/pgsql-bugs/\">pgsql-bugs@</a> регулярно репортят баги (как правило, минорные). Обычно исправление бага — это халява. Пишем тест, воспроизводящий баг. Переписываем код так, чтобы тест больше не падал. Шлем патч.<br>\r\n<br>\r\nОптимизация. Тоже халява — код должен делать то же самое, только быстрее. Пишем бенчмарк, воспроизводящий проблему с производительностью, переписываем код так, чтобы он работал быстрее, шлем патч.<br>\r\n<br>\r\nУлучшение документации и комментариев. Например, вы пытаетесь понять, как работает код, но не понимаете. Похоже, вы нашли место, где комментарии к коду можно улучшить!<br>\r\n<br>\r\nЧасто можно найти, что запатчить, собрав проект каким-то необычным компилятором (например, очень старой или очень новой версией GCC), на необычной платформе (ARM, PowerPC, ...) под необычной операционной системой (NetBSD, OpenIndiana). Тесты обычно не сыпятся, но пара варнингов при компиляции может проскочить. Еще часто помогает прогнать по коду какой-нибудь статический анализатор.<br>\r\n<br>\r\nЕсли у вас нет идеи для своего патча, вы можете <i>существенно</i> помочь проекту, сделав code review и/или протестировав чужой патч. Программисты, как правило, очень любят писать код, но не особо любят ревьювить и тестировать его. Поэтому ревьюверов в сообществе PostgreSQL прямо реально не хватает. Ревьювером, кстати, быть довольно просто. Нужно убедиться, что патч применяется, код после этого компилируется и проходит тесты, а также что задача, которую перед собой ставил автор, при этом решена. Если вам не ясно, как это проверить, возможно, автор недостаточно хорошо это описал. Это повод задать вопрос автору в соответствующем треде и перевести патч в состояние waiting on author. А если при этом вы еще и в состоянии читать код и давать адекватные советы по переименованию переменных и разбиению процедур на несколько, то вам просто цены нет! О code review, выставлении патчей на коммитфест и различных состояниях патчей речь пойдет далее.<br>\r\n<br>\r\n<h3>Про мейлинг листы и блоги</h3><br>\r\nВсе общение разработчиков PostgreSQL происходит в рассылке <a href=\"https://www.postgresql.org/list/pgsql-hackers/\">pgsql-hackers@</a>. Еще имеет смысл подписаться на <a href=\"https://www.postgresql.org/list/pgsql-committers/\">pgsql-committers@</a>. Туда прилетают уведомления о последних мержах в мастер, иногда завязывается обсуждение конкретного коммита. Трафик в этих двух мейлинг листах не такой уж большой, это вам не LKML. Их вполне реально читать со своего основного ящика без каких-либо фильтров (правда, я читаю далеко не все треды подряд). Я лично получаю их все на рабочий e-mail.<br>\r\n<br>\r\nЕще может иметь смысл подписаться на <a href=\"https://www.postgresql.org/list/pgsql-general/\">pgsql-general@</a> (общие вопросы) и уже упомянутый <a href=\"https://www.postgresql.org/list/pgsql-bugs/\">pgsql-bugs@</a> (багрепорты). Но, строго говоря, для разработки это не требуется.<br>\r\n<br>\r\nПо поводу выбора почтового клиента. В принципе, подойдет любой. Многие используют Thunderbird. Я долгое время сидел на Claws Mail, а сейчас переполз на <a href=\"https://eax.me/mutt/\">Mutt</a>. Видел, как кто-то из коллег использует GMail.<br>\r\n<br>\r\nХорошим тоном является не слать в рассылку HTML-письма. Текст письма по ширине стоит ограничить 72-я символами. Понятное дело, использовать можно только английский язык. Использовать аттачи, в отличие от того же LKML, не запрещается. Тяжелые аттачи лучше куда-нибудь заливать, а не слать напрямую в мейлинг лист.<br>\r\n<br>\r\nВ сообществе PostgreSQL, насколько мне известно, нет какого-либо code of conduct. Но это не отменяет необходимости быть вежливым, не использовать сарказм, никогда не переходить на личности, и так далее. Электронные письма, особенно на английском языке, часто получаются несколько сухими. Поэтому неплохой идеей будет использовать в тексте побольше слов вроде please, thank you, и так далее. Я лично стараюсь начинать любое письмо словами вроде «Thank you everyone for great comments!» и заканчивать чем-то вроде «As always, please don't hesitate to share any thoughts on this topic!». Попробуйте, и вы удивитесь, насколько дружелюбнее к вам станет сообщество.<br>\r\n<br>\r\nВозможно, стоило бы сказать пару слов про основных действующих лиц в рассылке, таких, как Tom Lane, Simon Riggs, Robert Haas, Andres Freund, Alvaro Herrera, Bruce Momjian, и других. Но проблема в том, что действующих лиц довольно много, и кто конкретно заинтересуется вашим патчем заранее сказать трудно. Поэтому скажу лишь, что неплохой идеей будет первое время читать подписи людей, которые вам отвечают, смотреть, на каких доменах находятся их e-mail, поискать их имена в git log ну или в Google в конце-то концов.<br>\r\n<br>\r\nКстати, некоторые люди из сообщества PostgreSQL ведут блоги (которые как раз можно найти благодаря Google), на которые не лишено смысла подписаться. Я лично в настоящее время подписан на следующие связанные с PostgreSQL RSS-фиды:<br>\r\n<br>\r\n<pre><code># PostgreSQL\nhttp://postgresmen.ru/news.xml\nhttp://planet.postgresql.org/rss20.xml\nhttp://habrahabr.ru/rss/company/postgrespro/blog/\nhttp://www.postgrespro.ru/rss\nhttp://www.postgresql.org/news.rss\nhttp://postgresweekly.com/rss/1ijl6aaa\nhttp://postgres-edu.blogspot.com/feeds/posts/default\nhttp://feeds.feedburner.com/depesz\nhttp://rhaas.blogspot.com/feeds/posts/default\nhttp://amitkapila16.blogspot.com/feeds/posts/default\nhttp://obartunov.livejournal.com/data/rss</code></pre><br>\r\nЗаметьте, что в список входит <a href=\"http://planet.postgresql.org/\">Планета PostgreSQL</a>, которая агрегирует многие блоги, которых нет в списке.<br>\r\n<br>\r\n<h3>Как послать патч</h3><br>\r\nВ общем случае, прежде, чем начинать работу над каким-то <i>большим</i> патчем, не лишено смысла написать в pgsql-hackers@ письмо-proposal с описанием того, что вы хотите сделать, как, и зачем. Может оказаться, что это никому особо и не нужно. Или наоборот, что это так нужно, что за последние лет 5 предлагалось несколько решений, о которых вы не знаете, и с которыми стоит предварительно ознакомиться. Ну или вам могут просто дать пару советов по реализации, куда стоит посмотреть, какие граничные случаи учесть, и так далее. Разработчики PostgreSQL — занятые люди, у которых своих дел хватает, так что не стоит бояться, что вашу гениальную идею кто-то тут же украдет. Скорее вам скажут, что это вряд ли будет работать, и предоставят возможность доказать обратное.<br>\r\n<br>\r\nПо поводу оформления кода. В PostgreSQL используется ANSI C, так что про всякие там С11, C++ или Rust сразу забудьте. Для форматирования кода используется утилита pgindent. Инструкцию по ее сборке вы найдете в исходниках PostgreSQL, в файле <a href=\"https://github.com/postgres/postgres/blob/master/src/tools/pgindent/README\">src/tools/pgindent/README</a>. Перед созданием патча всегда прогоняйте код через pgindent, иначе его никто даже смотреть не станет. (Но следите за тем, чтобы pgindent не вносил изменения там, где вы ничего не меняли! В этом случае, возможно, код будет проще отформатировать вручную.) В остальном каких-то особо строгих правил нет. Просто смотрите, как оформлен код в районе того места, куда вы вонзаетесь, и старайтесь писать так же.<br>\r\n<br>\r\nКогда патч готов, оправьте его в pgsql-hackers@, указав в subject метку [PATCH] и краткое описание. В теле письма расскажите, какую проблему решает патч, и каким образом он это делает. Почитайте архив рассылки, чтобы посмотреть, как это обычно выглядит. Если патч небольшой, например, исправляет пару опечаток, его могут принять сразу и без особых вопросов. В более сложных случаях патч нужно <a href=\"https://commitfest.postgresql.org/\">отправить на ближайший коммитфест</a>:<br>\r\n<br>\r\n<img src=\"https://habrastorage.org/files/241/400/08e/24140008e2d34b79b3cdbab1587ac525.png\" alt=\"PostgreSQL Commitfest\"><br>\r\n<br>\r\nКоммитфест — это местное название спринта. Один коммитфест длится один месяц. Например, сейчас открыт сентябрьский коммитфест. Все новые патчи добавляются в него. В начале сентября начнется рассмотрение патчей из сентябрьского коммитфеста, а все новые патчи будут добавляться в ноябрьский (в октябре коммитфеста нет, месяц правятся баги и так далее). Так продолжается до марта, всего 4 коммитфеста — в сентябре, ноябре, январе и марте. Затем наступает кодфриз, правятся баги, формируются альфа- и бета-релизы.<br>\r\n<br>\r\nПатчи на коммитфесте бывают в разных состояниях. Все они имеют говорящие названия. Needs review означает, что патчу требуется ревьювер. Waiting on author означает, что какие-то действия требуются со стороны автора патча. Ready for committer означает, что патч прошел кодревью и по нему больше нет вопросов. Один из коммитеров может ознакомиться с ним и либо вмержить, либо вернуть автору на доработку. Ну и так далее.<br>\r\n<br>\r\nЗапаситесь терпением. Если на ваш патч никто не реагирует, это не значит, что он никому не нужен. Просто сейчас все заняты другими патчами. Если ваш патч есть в коммитфесте и не висит в Waiting on author, про него никто не забудет, не переживайте. Если вам ответил ревьювер или коммитер, внимательно прочитайте ответ, внесите соответствующие изменения в патч и отправьте его новую версию. Спорить с ревьюверами или коммитерами, по моему личному опыту, занятие очень неблагодарное. Быстрее исправить код и послать исправленный патч. Более того, нередко потом понимаешь, что ревьювер или коммитер в общем-то был прав, а ты — нет. Впрочем, у некоторых моих коллег иной опыт, и они наоборот считают, что всегда нужно спорить.<br>\r\n<br>\r\nПока вы ждете реакции на ваш патч, неплохой идеей будет самим заревьювить чей-нибудь патч. В сообществе PostgreSQL есть такое негласное правило — если вы шлете патч за патчем, и сами при этом никого не ревьювите, то очень быстро перестанут ревьювить и вас. Более того, чем быстрее будут приняты или отклонены другие патчи на коммитфесте, тем быстрее очередь дойдет до вашего, тем больше у вас будет времени внести правки до закрытия коммитфеста.<br>\r\n<br>\r\n<h3>Заключение</h3><br>\r\nДополнительные материалы для самостоятельного изучения:<br>\r\n<br>\r\n<ul>\r\n<li><a href=\"http://postgres-edu.blogspot.ru/search/label/Hacking%20PostgreSQL\">Видеокурс «Hacking PostgreSQL» Анастасии Лубенниковой</a>. Замечательный курс о внутреннем устройстве PostgreSQL. Доступны видео и слайды.</li>\r\n<li><a href=\"https://www.amazon.com/Database-System-Implementation-Hector-Garcia-Molina/dp/0130402648/\">Книга Database System Implementation</a>. Как в ней написано, именно так PostgreSQL и работает.</li>\r\n<li><a href=\"https://eax.me/gdb/\">Основы отладки при помощи GDB</a>. Там же вы найдете ссылки на статьи про отладку при помощи LLDB, использование замечательного инструмента RR, и не только.</li>\r\n<li><a href=\"https://eax.me/c-cpp-profiling/\">О том, как профилировать код с использованием perf</a>, <a href=\"https://eax.me/bcc-ebpf/\">bcc/eBPF</a> и других инструментов. В статьях вы также найдете ссылки на материалы по DTrace и SystemTap.</li>\r\n<li><a href=\"https://eax.me/valgrind/\">Туториалы по Valgrind'у</a> и <a href=\"https://eax.me/c-static-analysis/\">статическим анализаторам для C/C++</a>. Эти инструменты помогают находить различного рода ошибки в коде, крайне полезно уметь ими пользоваться.</li>\r\n<li><a href=\"https://postgrespro.ru/jobs\">Наша компания перманентно нанимает</a>. Работа интересная, хотя и несколько специфичная. Привыкнув к недельным спринтам с еженедельной выкаткой нового кода, мне долгое время было непросто перестроиться.</li>\r\n</ul><br>\r\nЭто все, о чем я хотел сегодня рассказать. Если у вас есть вопросы, я буду рад ответить на них в комментариях.<br>\r\n<br>\r\nПродолжение: <a href=\"https://habrahabr.ru/company/postgrespro/blog/309488/\">Контрибьютим в PostgreSQL: примеры реальных патчей, часть 1 из N</a></div>"]},
{"Вышел первый онлайн-выпуск BSDMagazine": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"http://bsdmag.org/system/editions/photo1s/1021/medium/okladka_400.jpg\" alt=\"BSDMagazine\"><br>\r\n<br>\r\nBSDMagazine — журнал об операционных системах семейства BSD — Free/Open/Net/DragonFly BSD, MacOS, SunOS и дистрибутивах на их основе. С недавних пор журнал перестал публиковаться на бумаге, выпуск за март 2010 является первым онлайн-изданием. Ссылка для скачивания и содержание выпуска — под катом. <a name=\"habracut\"></a><br>\r\n<br>\r\nСодержание:<br>\r\n<ul>\r\n<li>Создай свой собственный сервер обновлений // Jason Helfman</li>\r\n<li>Использование OpenBSD и PF в качестве виртуального фаервола для Windows // Pedro Lereno</li>\r\n<li>Keeping FreeBSD Applications Up-To-Date *// Richard Bejtlich</li>\r\n<li>Борьба со спамом средствами OpenBSD // Girish Venkatachalam</li>\r\n<li>Выбор и установка оконного менеджера под FreeBSD // Rob Somerville</li>\r\n<li>BSD Live Desktops * // Jesse Smith</li>\r\n<li>Может ли BSD конкурировать с desktop-дистрибутивами? // Mike Bybee</li>\r\n</ul><br>\r\n<br>\r\n* решил, что английские названия будут звучать лучше моего перевода<br>\r\n<br>\r\n<a href=\"http://bsdmag.org/app/files/download?attachment=attachment1&amp;model=Article&amp;model_id=10867&amp;portal_id=134\">Скачать выпуск в PDF</a> | <a href=\"http://bsdmag.org/\">Оффсайт</a></div>"]},
{"ZSON: расширение PostgreSQL для прозрачного сжатия JSONB": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/files/b06/5b3/c39/b065b3c390ad4fca8eca729e5e4f2d51.png\"><br>\r\n<br>\r\nНедавно мы выложили на GitHub <a href=\"https://github.com/afiskon/zson\">ZSON</a>. ZSON — это расширение к PostgreSQL для прозрачного сжатия JSONB-документов. Сжатие осуществляется путем выделения строк, наиболее часто встречающихся в ваших документах, и построения словаря с этими строками. Притом строки могут быть не только ключами документа, но и значениями или, например, строками из вложенных массивов. В некоторых случаях ZSON позволяет уменьшить размер базы до двух раз и увеличить количество транзакций в секунду на 10%. В shared buffers документы хранятся в сжатом виде, за счет чего память тоже экономится.<br>\r\n<br>\r\nИнтересно? Читайте дальше, и вы узнаете, как пользоваться всем этим хозяйством на практике.<br>\r\n<a name=\"habracut\"></a><br>\r\n<h3>Замечания</h3><br>\r\nПрежде, чем перейти к основному содержимому статьи, хочется отметить несколько моментов:<br>\r\n<br>\r\n<ul>\r\n<li>Бенчмарк ZSON'а в данной статье не приводится. Заинтересованные читатели могут <a href=\"https://github.com/afiskon/zson/blob/master/docs/benchmark.md\">ознакомиться с ним здесь</a>. Примите во внимание, что на практике все очень сильно зависит от ваших данных, конфигурации, железа, версии СУБД и других факторов. <a href=\"https://eax.me/benchmarks/\">Не верьте синтетическим бенчмаркам</a>, проверяйте все самостоятельно!<br>\r\n<br>\r\n</li>\r\n<li>Вопрос написания расширений для PostgreSQL выходит за рамки этой статьи. Заинтересованные читатели могут <a href=\"https://eax.me/postgresql-extensions/\">ознакомиться с отдельной статьей по данной теме</a>, и далее по ссылкам. Тому, как ZSON работает внутри, если это кому-то интересно, я могу посвятить отдельную статью.<br>\r\n<br>\r\n</li>\r\n<li>PostgreSQL имеет встроенный алгоритм сжатия — PGLZ. ZSON не заменяет, а дополняет его. PGLZ сжимает каждый документ в отдельности. Он не может обнаружить, что в разных документах встречаются одни и те же строки. ZSON находит эти строки и заменяет их на 16-и битовые коды. Затем документы сжимаются PGLZ, как обычно (или не сжимаются, если итоговый документ маленький и/или не жмется).</li>\r\n</ul><br>\r\n<h3>Установка</h3><br>\r\nСборка ZSON из исходников и его установка осуществляются так:<br>\r\n<br>\r\n<pre><code class=\"bash\">git clone https://github.com/afiskon/zson.git\ncd zson\nsudo make install</code></pre><br>\r\nПосле установки прогоните тесты:<br>\r\n<br>\r\n<pre><code class=\"bash\">make installcheck</code></pre><br>\r\nВключите ZSON для вашей базы данных:<br>\r\n<br>\r\n<pre><code class=\"sql\">create extension zson;</code></pre><br>\r\nПоздравляю, ZSON установлен!<br>\r\n<br>\r\n<h3>Удаление</h3><br>\r\nКогда и если вы захотите удалить ZSON, просто выключите его:<br>\r\n<br>\r\n<pre><code class=\"sql\">drop extension zson;</code></pre><br>\r\nА затем совсем выпилите из PostgreSQL:<br>\r\n<br>\r\n<pre><code class=\"bash\">sudo make uninstall</code></pre><br>\r\nВсе созданные ZSON'ом типы, таблицы и так далее, будут вычищены автоматически.<br>\r\n<br>\r\n<h3>Использование</h3><br>\r\nПервым делом вы должны обучить ZSON на ваших типичных документах. В результате обучения строится словарь с наиболее часто встречающимися в ваших документах строками, который потом используется для сжатия. Обучение происходит с помощью следующей процедуры:<br>\r\n<br>\r\n<pre><code class=\"sql\">\nzson_learn(\n    tables_and_columns text[][],\n    max_examples int default 10000,\n    min_length int default 2,\n    max_length int default 128,\n    min_count int default 2\n)</code></pre><br>\r\nНапример:<br>\r\n<br>\r\n<pre><code class=\"sql\">select zson_learn('{{\"table1\", \"col1\"}, {\"table2\", \"col2\"}}');</code></pre><br>\r\nПосмотреть получившийся в итоге словарь можно так:<br>\r\n<br>\r\n<pre><code class=\"sql\">select * from zson_dict;</code></pre><br>\r\nТеперь вы можете использовать ZSON, как прозрачную замену типа JSONB:<br>\r\n<br>\r\n<pre><code>zson_test=# create table zson_example(x zson);\nCREATE TABLE\n\nzson_test=# insert into zson_example values ('{\"aaa\": 123}');\nINSERT 0 1\n\nzson_test=# select x -&gt; 'aaa' from zson_example;\n-[ RECORD 1 ]-\n?column? | 123</code></pre><br>\r\nВсе операторы и процедуры будут работать с ZSON точно так же, как и с JSONB.<br>\r\n<br>\r\n<h3>Миграция на новый словарь</h3><br>\r\nПо мере изменения схемы ваших документов сжатие может стать неэффективным из-за исчезновения одних строк и появления других. В этом случае вы можете переобучить ZSON на новых данных:<br>\r\n<br>\r\n<pre><code class=\"sql\">select zson_learn('{{\"table1\", \"col1\"}, {\"table2\", \"col2\"}}');</code></pre><br>\r\nПри этом создается новая версия словаря. При обновлении и создании новых документов они будут сжиматься с его помощью. Старые документы будут разжиматься с помощью той версии словаря, с которой они были сжаты. Обратите внимание, что словари кэшируются в памяти. Поэтому ZSON узнает о новом словаре не сразу, а спустя примерно минуту после его создания.<br>\r\n<br>\r\nОпределить, с помощью какой версии словаря был сжат конкретный документ, можно при помощи процедуры zson_info:<br>\r\n<br>\r\n<pre><code>zson_test=# select zson_info(x) from test_compress where id = 1;\n-[ RECORD 1 ]---------------------------------------------------\nzson_info | zson version = 0, dict version = 1, ...\n\nzson_test=# select zson_info(x) from test_compress where id = 2;\n-[ RECORD 1 ]---------------------------------------------------\nzson_info | zson version = 0, dict version = 0, ...</code></pre><br>\r\nЕсли вы <b>абсолютно уверены</b>, что <b>все</b> документы в вашей базе сжаты с помощью новой версии словаря, вы можете безопасно удалить старый словарь:<br>\r\n<br>\r\n<pre><code class=\"sql\">delete from zson_dict where dict_id = 0;</code></pre><br>\r\nНа практике, впрочем, в этом мало смысла. Вы сэкономите лишь пару килобайт места на диске. Параноик внутри меня считает, что риск потерять данные из-за маааленькой невнимательности того не стоит.<br>\r\n<br>\r\n<h3>Как понять, что нужно обновить словарь?</h3><br>\r\nК сожалению, трудно рекомендовать универсальный подход. Например, вы можете время от времени проверять средний размер документа в вашей базе:<br>\r\n<br>\r\n<pre><code class=\"sql\">select pg_table_size('tt') / (select count(*) from tt)</code></pre><br>\r\nЕсли он стал увеличиваться, значит пришло время обновиться словарь. Еще можно переучивать ZSON просто время от времени, например, раз в год.<br>\r\n<br>\r\nНаконец, разработчики приложения сами знают, когда они сильно меняют схему документов. Можно включить переобучение ZSON в миграционные скрипты или инструкцию по обновлению приложения.<br>\r\n<br>\r\nПри сильном желании можно придумать и другие подходы. В общем, все сильно зависит от ситуации.<br>\r\n<br>\r\n<h3>Заключение</h3><br>\r\nКак видите, благодаря ZSON вы получаете лучшее из двух миров — гибкость schemaless данных, совмещенную с компактностью реляционной модели. При этом на стороне приложения вообще ничего не нужно делать, все происходит прозрачно, на стороне самой СУБД.<br>\r\n<br>\r\nЕсли у вас есть вопросы, я буду рад ответить на них в комментариях. Любой фидбек, а также pull requests горячо приветствуются.</div>"]},
{"Mutt, ssmtp и отправка отчетов": ["<div class=\"post__text post__text-html js-mediator-article\">В свое время, когда меня еще не было на Хабре, эта статья была опубликована в песочнице. К сожалению, она никому не понравилась и со временем была удалена. Долго думал, что с ней делать — забить, запостить таки на Хабре или в своем блоге <a href=\"https://eax.me/\">Записки программиста</a>. Решил, раз она писалась для Хабра, пусть на нем и будет опубликована. Итак, под катом — статья о практике отправки отчетов по e-mail. Сейчас, перечитывая текст, понимаю, что статья — не фонтан, но может кому-нибудь пригодится.<a name=\"habracut\"></a><br>\r\n<br>\r\nЧасто передо мной встает задача вроде такой: необходимо ежемесячно (или еженедельно/ежедневно) обработать такие-то логи, построить по ним отчет и отправить его на заданный E-Mail. В этой статье я как раз хотел бы рассказать о второй части такой задачи, а именно об отправке отчетов. Казалось бы, такая рутинная операция, но трудности с ней возникают чаще, чем может показаться на первый взгляд.<br>\r\n<br>\r\nЯ предпочитаю использовать уже готовые, проверенные временем, программы, а не писать каждый раз собственные скрипты. В большинстве случаев нужная программа уже была когда-то кем-то написана, зачем изобретать велосипед?<br>\r\n<br>\r\nДля отправки отчетов я пользуюсь mutt. В нем меня привлекает простота интерфейса, возраст (читай — стабильность) программы и то, что mutt портирован если не под все, то почти под все unix-like системы. В моей любимой FreeBSD искать его следует в /usr/ports/mail/mutt.<br>\r\n<br>\r\nЧтобы при помощи mutt послать письмо с аттачем, достаточно команды<br>\r\n<br>\r\n<code>mutt -s Subject -a File User@Host.com</code><br>\r\n<br>\r\nгде Subject — тема сообщения, File — имя прикрепляемого файла, а User@Host.com — получатель письма. К письму можно прикрепить несколько файлов или указать несколько получателей. Текст письма программа читает из stdin.<br>\r\n<br>\r\nПо умолчанию mutt использует sendmail в качестве MTA. Обычно с этим не возникает трудностей — после установки mutt мы можем сразу приступить к написанию скриптов и все будет прекрасно работать. Но мне приходилось сталкиваться с ситуацией, когда посылка писем напрямую с сервера просто запрещена правилами фаервола. В этом случае следует использовать сторонний SMTP сервер.<br>\r\n<br>\r\nПроблема в том, что mutt не имеет функций MTA, то есть работа с SMTP — не его задача. Тем не менее, можно научить его слать почту через заданный smtp-сервер и поможет ему в этом программа ssmtp.<br>\r\n<br>\r\nСтрого говоря, ssmtp является не MTA, а просто smtp-клиентом, эмулирующим работу sendmail. Если вы, как и я, пользуетесь FreeBSD, то можете поставить ssmtp из портов — /usr/ports/mail/ssmtp.<br>\r\n<br>\r\nНастройка ssmtp производится путем редактирования файла /usr/local/etc/ssmtp/ssmtp.conf (в вашей ОС путь к файлу может быть другим). Вот как он примерно выглядит:<br>\r\n<br>\r\n<code>root=reports@example.ru # от чьего имени шлем письма<br>\r\nmailhub=smtp.example.ru:465 # smtp-сервер и порт<br>\r\nhostname=localhost # имя нашего хоста, желательно вписать верное<br>\r\nUseTLS=Yes # используем зашифрованное соединение<br>\r\nAuthUser=reports@example.ru # логин<br>\r\nAuthPass=qwerty # пароль<br>\r\nFromLineOverride=Yes # Поле From: может задавать mutt</code><br>\r\n<br>\r\nЕсли вы хотите слать отчеты через Gmail, конфиг будет выглядеть немного иначе:<br>\r\n<br>\r\n<code>root=reports@gmail.com<br>\r\nmailhub=smtp.gmail.com:587<br>\r\nhostname=localhost<br>\r\nUseSTARTTLS=YES<br>\r\nAuthUser=reports@gmail.com<br>\r\nAuthPass=qwerty</code><br>\r\n<br>\r\nПытаемся послать тестовое письмо с помощью ssmtp:<br>\r\n<br>\r\n<code>echo \"\" | ssmtp -v -s Hello admin@example.ru</code><br>\r\n<br>\r\nЕсли письмо успешно дошло, значит все было сделано правильно. Если ssmtp говорит нечто вроде:<br>\r\n<br>\r\n<code>. . .<br>\r\n[-&gt;] MAIL FROM:&lt;root@localhost&gt;<br>\r\n[&lt;-] 573 root@localhost failed to route the address<br>\r\nssmtp: 573 root@localhost failed to route the address</code><br>\r\n<br>\r\nтоже не проблема, просто ssmtp указал неверный адрес отправителя, и smtp-сервер это заметил. Когда будем слать почту через mutt, все будет задано верно.<br>\r\n<br>\r\nЧтобы mutt слал почту через ssmtp, в домашнем каталоге пользователя, от имени которого мы собираемся слать отчеты, нужно подправить файл .muttrc<br>\r\n<br>\r\n<code>set sendmail=\"/usr/local/sbin/ssmtp\" # путь к ssmtp<br>\r\nset realname=\"Example Report System\" # имя отправителя<br>\r\nset from=\"reports@example.ru\" # e-mail отправителя</code><br>\r\n<br>\r\nПроверяем работу mutt:<br>\r\n<br>\r\n<code>echo \"\" | mutt -s Hello admin@example.ru</code><br>\r\n<br>\r\nПисьмо должно успешно дойти до получателя. Если вы хотите использовать mutt в скриптах, запускаемых по крону, нужно иметь ввиду, что mutt находится в каталоге /usr/local/bin, который по умолчанию не прописан в переменную окружения PATH в вашем crontab. Решения два — либо исправить переменную окружения PATH в кронтабе, либо использовать полное имя mutt в скриптах.<br>\r\n<br>\r\nБывает и такое, что на сервере, с которого приходится слать отчеты, у нас нет root-привилегий. В этом случае либо придется уговаривать админа установить и настроить mutt, либо все-таки написать свой собственный скрипт отправки электронной почты. Но это уже совсем другая история.</div>"]},
{"Еще одна новая фича pg_filedump: восстанавливаем каталог PostgreSQL": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/files/ac3/5e5/6d8/ac35e56d8e9140bd8c0f9b0d2edf83d0.jpg\"><br>\r\n<p><br>\r\nВ <a href=\"https://habrahabr.ru/company/postgrespro/blog/319770/\">прошлой статье</a> мы узнали, как при помощи утилиты pg_filedump можно восстановить данные, или, по крайней мере, какую-то их часть, из полностью убитой базы PostgreSQL. При этом предполагалось, что мы откуда-то знаем номера сегментов, соответствующих таблице. Если мы знаем часть содержимого таблицы, ее сегменты действительно не сложно найти, например, простым grep'ом. Однако в более общем случае это не так-то просто сделать. К тому же, предполагалось, что мы знаем точную схему таблиц, что тоже далеко не факт. Так вот, недавно мы с коллегами сделали <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commit;h=5c5ba458fa154183d11d43218adf1504873728fd\">новый патч</a> для pg_filedump, позволяющий решить названные проблемы. </p><a name=\"habracut\"></a><br>\r\n<p>Итак, допустим, мы хотим восстановить таблицу с именем test. Если имя таблицы мы не помним, это не страшно, так так используя описанный далее прием можно получить имена всех таблиц в базе. Информация о таблицах храниться в каталожной таблице pg_class, сегмент которой всегда имеет номер 1259.</p><br>\r\n<p>Используя последнюю версию pg_filedump, мы можем прочитать pg_class следующим образом:</p><br>\r\n<pre><code>./pg_filedump -D name,oid,oid,oid,oid,oid,oid,~ /path/to/base/16384/1259 | grep COPY | grep test</code></pre><br>\r\n<p>Обратите внимание на список типов для декодирования, который мы передаем pg_filedump:</p><br>\r\n<pre><code>name,oid,oid,oid,oid,oid,oid,~</code></pre><br>\r\n<p>Тут мы в начале передаем имена типов первых семи столбцов таблицы (схема pg_class известна и <a href=\"https://www.postgresql.org/docs/9.6/static/catalog-pg-class.html\">описана в документации</a>), а тильда говорит игнорировать остальные столбцы. В данном случае они нам все равно не интересны, незачем перечислять их все.</p><br>\r\n<p>Пример вывода:</p><br>\r\n<pre><code>COPY: test  2200    16387   0   10  0   16385\nCOPY: test  2200    16387   0   10  0   16385\nCOPY: test_pkey 2200    0   0   10  403 16391</code></pre><br>\r\n<p>Последний столбец — это relfilenode, то есть номер сегмента. Он то нам и нужен! Запомним, 16385.</p><br>\r\n<p>Но постойте-ка, ведь мы не знаем схему таблицы. Узнать ее нам поможет каталожная таблица pg_attribute, relfilenode которой захардкожен и равен 1249. Кстати, relfilenode всех каталожных таблиц вы можете подсмотреть в <a href=\"https://github.com/postgres/postgres/blob/master/src/include/catalog/pg_class.h\">файле pg_class.h</a>.</p><br>\r\n<p>Открываем <a href=\"https://www.postgresql.org/docs/9.6/static/catalog-pg-attribute.html\">доку по pg_attribute</a>, декодируем:</p><br>\r\n<pre><code>./pg_filedump -D oid,name,oid,int,smallint,~ /path/to/base/16384/1249 | grep COPY | grep 16385</code></pre><br>\r\n<p>Пример вывода:</p><br>\r\n<pre><code>COPY: 16385 k   23  -1  4\nCOPY: 16385 v   25  -1  -1\nCOPY: 16385 ctid    27  0   6\nCOPY: 16385 xmin    28  0   4\nCOPY: 16385 cmin    29  0   4\nCOPY: 16385 xmax    28  0   4\nCOPY: 16385 cmax    29  0   4\nCOPY: 16385 tableoid    26  0   4</code></pre><br>\r\n<p>Как видите, таблица имеет два столбца с именами k и v (остальные столбцы системные, они нужны для работы MVCC и вот этого всего). Здесь 23 и 25 — это atttypid, то есть, типы столбцов. Но как понять, что это за типы?</p><br>\r\n<p>Ответ содержится в каталожной таблице pg_type (relfilenode = 1247, <a href=\"https://www.postgresql.org/docs/9.6/static/catalog-pg-type.html\">дока</a>):</p><br>\r\n<pre><code>./pg_filedump -i -D name,~ /path/to/base/16384/1247 | grep -A5 -E 'OID: (23|25)'</code></pre><br>\r\n<p>Пример вывода:</p><br>\r\n<pre><code>  XMIN: 1  XMAX: 0  CID|XVAC: 0  OID: 23\n  Block Id: 0  linp Index: 8   Attributes: 30   Size: 32\n  infomask: 0x0909 (HASNULL|HASOID|XMIN_COMMITTED|XMAX_INVALID) \n  t_bits: [0]: 0xff [1]: 0xff [2]: 0xff [3]: 0x07 \n\nCOPY: int4\n--\n  XMIN: 1  XMAX: 0  CID|XVAC: 0  OID: 25\n  Block Id: 0  linp Index: 10   Attributes: 30   Size: 32\n  infomask: 0x0909 (HASNULL|HASOID|XMIN_COMMITTED|XMAX_INVALID) \n  t_bits: [0]: 0xff [1]: 0xff [2]: 0xff [3]: 0x07 \n\nCOPY: text</code></pre><br>\r\n<p>Итак, теперь у нас на руках есть вся необходимая информация. Таблица называется test, имеет relfilenode 16385 и содержит два столбца — k с типом int4 и v с типом text. Теперь мы можем сдампить ее содержимое, как было описано в <a href=\"https://habrahabr.ru/company/postgrespro/blog/319770/\">предыдущей статье</a>.</p><br>\r\n<p>Надеюсь, что на практике эти знания вам никогда не понадобятся :) Если у вас есть вопросы или дополнения, буду рад ознакомиться с ними в комментариях!</p></div>"]},
{"Позвольте представить — Записки программиста": ["<div class=\"post__text post__text-html js-mediator-article\">Интернет-журнал <a href=\"https://eax.me/\" title=\"записки программиста\">Записки программиста</a> главным образом посвящен таким непростым вещам, как unix-like системам (главным образом — FreeBSD) и программированию на С/C++ и Perl. Тем не менее, я стараюсь время от времени писать посты, рассчитанные на бОльшую целевую аудиторию, потому, надеюсь, блог заинтересует многих.<br>\r\n<br>\r\nЧуть подробнее — под катом. <a name=\"habracut\"></a><br>\r\n<br>\r\nЧто еще рассказать? Пишу я по ~ 5 постов в месяц, и стараюсь не опускать планку. Мои посты — это не «Доброе утро, Тви!», а довольно крупные и (надеюсь) интересные мануалы/рассказы/фото-отчеты. Кроме упомянутых Perl и FreeBSD я пишу обзоры железок, попадающих мне в руки, прочитанных книгах, посещенных конференциях, корпоративных вечерниках и других интересных вещах, с которыми я сталкиваюсь в жизни.<br>\r\n<br>\r\nНадеюсь, «записки» придутся Вам по душе. Есть вопросы или предложения по работе блога — с радостью отвечу/выслушаю.<br>\r\n<br>\r\n<i>Надеюсь, в этом разделе можно пропиарить свой блог? Если что не так — извиняйте.</i></div>"]},
{"Пример восстановления таблиц PostgreSQL с помощью новой мега фичи pg_filedump": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/files/85d/2a5/e99/85d2a5e9970d4c1382100c56feed6d61.jpg\"><br>\r\n<br>\r\nПозвольте я расскажу вам об одной классной фиче, которую мы с коллегами из <a href=\"https://postgrespro.ru/\">Postgres Pro</a> недавно запилили в утилите <a href=\"https://wiki.postgresql.org/wiki/Pg_filedump\">pg_filedump</a>. Фича эта позволяет частично восстанавливать данные из базы, даже в случае, если база была сильно повреждена и инстанс PostgreSQL с такой базой уже не запустишь. Конечно, хочется верить, что потребность в таком функционале возникает крайне редко. Но на всякий случай нечто подобное хотелось бы иметь под рукой. Читайте дальше, и вы узнаете, как данная фича выглядит в действии. <a name=\"habracut\"></a><br>\r\n<br>\r\nЧастичное восстановление данных было представлено в <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commitdiff;h=52fa0201f97808d518c64bcb9696f2a350678aa5;hp=bcacee12834e211179a6feb85666b8a511393790\">коммите 52fa0201</a>:<br>\r\n<br>\r\n<code>commit 52fa0201f97808d518c64bcb9696f2a350678aa5<br>\r\nAuthor: Teodor Sigaev &lt;teodor@sigaev.ru&gt;<br>\r\nDate: Tue Jan 17 16:01:12 2017 +0300<br>\r\n<br>\r\nPartial data recovery (-D flag).<br>\r\n<br>\r\nThis feature allows to partially recover data from a given segment file<br>\r\n in format suitable for using in COPY FROM statement. List of supported<br>\r\n data types is currently not full and TOAST is not yet supported, but<br>\r\n it's better than nothing. Hopefully data recovery will be improved in<br>\r\n the future.<br>\r\n<br>\r\nImplemented by Aleksander Alekseev, reviewed by Dmitry Ivanov, tested<br>\r\n by Dmitry Ivanov and Grigoriy Smolkin.</code><br>\r\n<br>\r\nДопустим, есть какая-то таблица:<br>\r\n<br>\r\n<pre><code class=\"sql\">create table tt (x int, y bool, z text, w timestamp);</code></pre><br>\r\n… заполненная какими-то данными:<br>\r\n<br>\r\n<pre><code class=\"sql\">insert into tt values(123, true, 'Text test test', now());\ninsert into tt values(456, null, 'Ололо трооло', null);\ncheckpoint;</code></pre><br>\r\nЗдесь я говорю checkpoint, чтобы данные обязательно попали на диск. Иначе они попадут в WAL, но buffer manager будет держать их в памяти, пока таплы (tuple, кортеж, строка в таблице) не будут вытеснены более новыми и/или часто используемыми таплами. <i>Или чекпоинтом по таймауту/накоплению max_wal. Думаю, это самый частый сценарий для синка страницы на диск. — прим. <a href=\"https://github.com/kelvich\">Стаса Кельвича</a>.</i><br>\r\n<br>\r\nТакже узнаем имя сегмента, соответствующего таблице:<br>\r\n<br>\r\n<pre><code class=\"sql\">select relfilenode from pg_class where relname = 'tt';</code></pre><br>\r\nВ моем случае relfilenode у таблицы был 16393. Найдем этот сегмент (или сегменты, если таблица больше 1 Гб) на диске:<br>\r\n<br>\r\n<pre><code class=\"bash\">find /path/to/db/ -type f | grep 16393</code></pre><br>\r\nСкопируем его куда-нибудь и представим, что нам хочется восстановить данные, имея на руках только файл сегмента.<br>\r\n<br>\r\nДля этого соберем последнюю версию pg_filedump:<br>\r\n<br>\r\n<pre><code class=\"bash\">git clone git://git.postgresql.org/git/pg_filedump.git\ncd pg_filedump\nmake\n</code></pre><br>\r\nОбычно схема базы известна, так как на руках есть приложение, которое с ней работает. Значит, мы знаем типы столбцов в таблице и можем декодировать их таким образом:<br>\r\n<br>\r\n<pre><code class=\"bash\">./pg_filedump -D int,bool,text,timestamp /path/to/db/base/16384/16393</code></pre><br>\r\nПример вывода:<br>\r\n<br>\r\n<pre><code>*******************************************************************\n* PostgreSQL File/Block Formatted Dump Utility - Version 9.6.0\n*\n* File: /home/eax/work/postgrespro/postgresql-install/data-master/base/16384/16393\n* Options used: -D int,bool,text,timestamp\n*\n* Dump created on: Tue Jan 17 16:28:07 2017\n*******************************************************************\n\nBlock    0 ********************************************************\n&lt;Header&gt; -----\n Block Offset: 0x00000000         Offsets: Lower      32 (0x0020)\n Block: Size 8192  Version    4            Upper    8080 (0x1f90)\n LSN:  logid      0 recoff 0x0301e4c0      Special  8192 (0x2000)\n Items:    2                      Free Space: 8048\n Checksum: 0x0000  Prune XID: 0x00000000  Flags: 0x0000 ()\n Length (including item array): 32\n\n&lt;Data&gt; ------\n Item   1 -- Length:   56  Offset: 8136 (0x1fc8)  Flags: NORMAL\nCOPY: 123   t   Text test test  2017-01-17 16:25:03.448488\n Item   2 -- Length:   52  Offset: 8080 (0x1f90)  Flags: NORMAL\nCOPY: 456   \\N  Ололо трооло    \\N\n\n*** End of File Encountered. Last Block Read: 0 ***\n</code></pre><br>\r\nТут довольно много данных, так как pg_filedump выводит информацию о каждой странице в сегменте и декодирует заголовок каждого тапла. К счастью, можно довольно просто отделить мух от котлет, например, так:<br>\r\n<br>\r\n<pre><code class=\"bash\">pg_fiedump -D ...как..раньше... | grep COPY | perl -lne 's/^COPY: //g; print;' &gt; /tmp/copy.txt\ncat /tmp/copy.txt</code></pre><br>\r\nСодержимое файла copy.txt:<br>\r\n<br>\r\n<pre><code>123 t   Text test test  2017-01-17 16:25:03.448488\n456 \\N  Ололо трооло    \\N</code></pre><br>\r\nЭто данные нашей таблицы в формате, пригодном для использования в запросе COPY FROM. Проверяем:<br>\r\n<br>\r\n<pre><code class=\"sql\">create table tt2 (x int, y bool, z text, w timestamp);\ncopy tt2 from '/tmp/copy.txt';\nselect * from tt2;</code></pre><br>\r\nРезультат:<br>\r\n<br>\r\n<pre><code>  x  | y |       z        |             w\n-----+---+----------------+----------------------------\n 123 | t | Text test test | 2017-01-17 16:25:03.448488\n 456 |   | Ололо трооло   |\n(2 rows)</code></pre><br>\r\nКак видите, все данные успешно восстановлены.<br>\r\n<br>\r\nЕстественно, это был несколько упрощенный пример и на практике все сложнее. Во-первых, список поддерживаемых типов на данный момент несколько ограничен:<br>\r\n<br>\r\n<pre><code class=\"cpp\">static ParseCallbackTableItem callback_table[] = {\n    { \"smallserial\", &amp;decode_smallint },\n    { \"smallint\", &amp;decode_smallint },\n    { \"int\", &amp;decode_int },\n    { \"serial\", &amp;decode_int },\n    { \"bigint\", &amp;decode_bigint },\n    { \"bigserial\", &amp;decode_bigint },\n    { \"time\", &amp;decode_time },\n    { \"timetz\", &amp;decode_timetz },\n    { \"date\", &amp;decode_date },\n    { \"timestamp\", &amp;decode_timestamp },\n    { \"float4\", &amp;decode_float4 },\n    { \"float8\", &amp;decode_float8 },\n    { \"float\", &amp;decode_float8 },\n    { \"bool\", &amp;decode_bool },\n    { \"uuid\", &amp;decode_uuid },\n    { \"macaddr\", &amp;decode_macaddr },\n\n    /* internally all string types are stored the same way */\n    { \"char\", &amp;decode_string },\n    { \"varchar\", &amp;decode_string },\n    { \"text\", &amp;decode_string },\n    { \"json\", &amp;decode_string },\n    { \"xml\", &amp;decode_string },\n    { NULL, NULL},\n};</code></pre><br>\r\nВо-вторых, TOAST сейчас не поддерживается. Если строка хранится в несжатом виде или сжата на странице in-place, pg_filedump ее успешно восстановит (если сжатые данные не были испорчены). Однако если строка была перенесена во внешнюю TOAST-таблицу, вместо строки вы получите просто \"(TOASTED)\". В принципе, поддержка TOAST — не нерешаемая задача. Нужно только научить pg_filedump парсить каталог и находить соответствующую TOAST-таблицу. Просто пока что этого никто не сделал. Возможно, поддержка TOAST будет добавлена в будущих версиях pg_filedump.<br>\r\n<br>\r\nНаконец, на практике схема базы данных иногда меняется, столбцы в таблице появляются и исчезают. Удаление столбцов — не такая уж большая проблема, так как физически в тапле этот столбец остается, просто он всегда равен null. Вот с добавлением чуть сложнее, так как из-за него таплы в рамках одной таблицы могут иметь переменное число атрибутов. Если число атрибутов в тапле не соответствует количеству атрибутов, указанных пользователем, pg_filedump просто показывает предупреждение с частично декодированными данными, и переходит к следующему таплу. Это значит, что на практике парсинг вывода pg_filedump будет чуть сложнее, ну или что вам придется прогнать его несколько раз с разными списками атрибутов.<br>\r\n<br>\r\nНа мой взгляд, да и не только мой, как <i>крайнее</i> средство восстановление данных, лучше иметь хотя бы такое, чем не иметь никакого :) Если у вас есть идеи по дальнейшему улучшению представленного функционала, да и вообще любые замечания и дополнения, мне будет крайне интересно ознакомиться с ними в комментариях!<br>\r\n<br>\r\nТакже вас могут заинтересовать статьи:<br>\r\n<ul>\r\n<li><a href=\"https://habrahabr.ru/company/postgrespro/blog/308442/\">Становимся контрибьютером в PostgreSQL</a>;</li>\r\n<li><a href=\"https://eax.me/postgresql-replication/\">Потоковая репликация в PostgreSQL и пример фейловера</a>;</li>\r\n</ul><br>\r\n<br>\r\n <br>\r\n<br>\r\nПродолжение — <a href=\"https://habrahabr.ru/company/postgrespro/blog/323644/\">Еще одна новая фича pg_filedump: восстанавливаем каталог PostgreSQL</a>.</div>"]},
{"Что нового в PostgreSQL 11: встроенный веб-поиск": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/webt/lq/dc/us/lqdcusv5zw4a5q3xo8vtjz2whxu.jpeg\"><br>\r\n<br>\r\n<a href=\"https://habrahabr.ru/company/postgrespro/blog/353126/\">Продолжая</a> тему интересных возможностей грядущего релиза PostgreSQL 11, я хотел бы рассказать про <b>новую встроенную функцию websearch_to_tsquery</b>. Соответствующий <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=1664ae1978bf0f5ee940dc2fc8313e6400a7e7da\">патч</a> разработали Виктор Дробный и Дмитрий Иванов, с правками от Федора Сигаева. Давайте же разберемся, что реализовано в этом патче. <a name=\"habracut\"></a><br>\r\n<br>\r\nКазалось бы, <a href=\"https://eax.me/postgresql-full-text-search/\">полнотекстовый поиск</a> есть в PostgreSQL уже давно, и он очень даже неплохо работает. Что тут еще можно было добавить? <br>\r\n<br>\r\nПредставьте, что вы делаете интернет-магазин на базе PostgreSQL и вам нужен поиск по товарам. Вот вам прилетела форма с поисковым запросом. Для поиска по базе из этого запроса нужно как-то построить tsvector. Можно сделать это с помощью функции to_tsquery. Но to_tsquery ожидает, что строка будет в определенном формате:<br>\r\n<br>\r\n<code>=# select to_tsquery('foo bar baz');<br>\r\nERROR: syntax error in tsquery: \"foo bar baz\"<br>\r\n<br>\r\n=# select to_tsquery('foo &amp; bar &amp; baz');<br>\r\n to_tsquery <br>\r\n-----------------------<br>\r\n 'foo' &amp; 'bar' &amp; 'baz'<br>\r\n</code><br>\r\nДругими словами, в этом случае придется написать функцию, преобразующую запрос пользователя в запрос, понятный to_tsquery. Неудобно. Отчасти эту проблему решают функции plainto_tsquery и phraseto_tsquery:<br>\r\n<br>\r\n<code>=# select plainto_tsquery('foo bar baz');<br>\r\n plainto_tsquery <br>\r\n-----------------------<br>\r\n 'foo' &amp; 'bar' &amp; 'baz'<br>\r\n<br>\r\n=# select phraseto_tsquery('foo bar baz');<br>\r\n phraseto_tsquery <br>\r\n---------------------------<br>\r\n 'foo' &lt;-&gt; 'bar' &lt;-&gt; 'baz'<br>\r\n</code><br>\r\nНо с ними есть проблема. Дело в том, что пользователь может интуитивно воспользоваться кавычками или, скажем, какими-то булевыми операторами, потому что это работает у Google, Яндекса и других поисковых систем. Давайте посмотрим, что произойдет в этом случае:<br>\r\n<br>\r\n<code>=# select plainto_tsquery('\"foo bar\" -baz or qux');<br>\r\n plainto_tsquery <br>\r\n-------------------------------<br>\r\n 'foo' &amp; 'bar' &amp; 'baz' &amp; 'qux'<br>\r\n</code><br>\r\nВсе сломалось! Ой. Неужели все-таки придется писать свой парсер?<br>\r\n<br>\r\nВот чтобы его не приходилось писать с нуля для каждого приложения, начиная с PostgreSQL 11 соответствующий парсер теперь будет прямо в СУБД:<br>\r\n<br>\r\n<code>=# select websearch_to_tsquery('\"foo bar\" -baz or qux');<br>\r\n websearch_to_tsquery <br>\r\n----------------------------------<br>\r\n 'foo' &lt;-&gt; 'bar' &amp; !'baz' | 'qux'<br>\r\n</code><br>\r\nПомимо того, что websearch_to_tsquery понимает кавычки, знак минус и булевы операторы, он интересен тем, что игнорирует любые попытки сделать синтаксическую ошибку. То есть, вы никогда не получите ошибку, на выходе всегда будет <i>какой-то</i> tsquery:<br>\r\n<br>\r\n<code>=# select websearch_to_tsquery('-\"foo bar\" ((( baz or or qux !@#$%^&amp;*_+-=');<br>\r\n websearch_to_tsquery <br>\r\n--------------------------------------<br>\r\n !( 'foo' &lt;-&gt; 'bar' ) &amp; 'baz' | 'qux'<br>\r\n</code><br>\r\nЕще из особенностей функции следует отметить тот факт, что она игнорирует любые скобки. То есть, вот так не прокатит:<br>\r\n<br>\r\n<code>=# select websearch_to_tsquery('foo and (bar or baz)');<br>\r\n websearch_to_tsquery <br>\r\n-----------------------<br>\r\n 'foo' &amp; 'bar' | 'baz'<br>\r\n</code><br>\r\nДанное поведение было выбрано из соображений, что нормальные люди (не айтишники :trollface:) на практике скобочки все равно не используют. Просто игнорируя их, мы существенно упрощаем реализацию фичи «сделать так, чтобы функция никогда не завершалась с ошибкой», да и разбор запроса будет работать быстрее. Возможно, флаг, включающий поддержку скобочек, появится в будущих версиях.<br>\r\n<br>\r\nТакая вот несложная, но полезная функция. Как минимум, она делает полнотекстовый поиск в PostgreSQL не хуже, чем он был до этого, и позволяет разработчикам упростить код своих приложений.</div>"]},
{"Примеры реальных патчей в PostgreSQL: часть 3 из N": ["<div class=\"post__text post__text-html js-mediator-article\"><div style=\"text-align:center;\"><img src=\"https://habrastorage.org/files/52b/b5f/e73/52bb5fe73bb648148d5d6abe0e3009a1.png\"></div><br>\r\n<p>Сегодня я хотел бы вновь рассказать о некоторых патчах, принятых за последнее время в PostgreSQL (а также утилиту pg_filedump). Аналогичные статьи, опубликованные на Хабре ранее, набрали достаточно много плюсиков, что заставляет думать, что они представляют для кого-то интерес. Если вы пропустили предыдущие статьи, вот они — <a href=\"https://habrahabr.ru/company/postgrespro/blog/308442/\">раз</a>, <a href=\"https://habrahabr.ru/company/postgrespro/blog/309488/\">два</a>, <a href=\"https://habrahabr.ru/company/postgrespro/blog/310372/\">три</a>. Несмотря на то, что рассмотренные патчи были написаны мной, не стоит забывать о вкладе людей, которые их ревьювили и тестировали. Проделанная этими людьми работа зачастую оказывается больше и сложнее работы самого автора. Особо активное участие в разработке рассмотренных пачтей приняли Федор Сигаев, Robert Haas, Tom Lane, Дмитрий Иванов, Григорий Смолкин, Andres Freund, Анастасия Лубенникова и Tels. <a name=\"habracut\"></a></p><br>\r\n<p><b>11. pg_filedump: возвращение ненулевого кода возврата в случае ошибок</b></p><br>\r\n<p>Напомню, что <a href=\"https://wiki.postgresql.org/wiki/Pg_filedump\">утилита pg_filedump</a> предназначена для декодирования сегментов таблиц и вывода информации о заголовках страниц и кортежей. Было замечено, что при несовпадении контрольных сумм страниц с их содержимым, pg_filedump выводит соответствующее предупреждение, однако возвращает нулевой код возврата. Что как бы не совсем правильно, особенно если утилита используется в shell-скриптах.</p><br>\r\n<p>Патч исправляет эту ситуацию. Теперь pg_filedump возвращает ненулевой код при обнаружении любых ошибок, как в контрольных суммах, так и любых других:</p><br>\r\n<pre><code class=\"diff\">+/* Program exit code */\n+static int exitCode = 0;\n+\n /***\n  * Function Prototypes\n  */\n@@ -191,6 +194,7 @@ ConsumeOptions(int numOptions, char **options)\n                        {\n                                rc = OPT_RC_INVALID;\n                                printf(\"Error: Missing range start identifier.\\n\");\n+                               exitCode = 1;\n                                break;\n                        }\n\n@@ -205,6 +209,7 @@ ConsumeOptions(int numOptions, char **options)\n                                rc = OPT_RC_INVALID;\n                                printf(\"Error: Invalid range start identifier &lt;%s&gt;.\\n\",\n                                           optionString);\n+                               exitCode = 1;\n                                break;\n                        }\n\n(...и так далее...)\n\n@@ -1746,5 +1823,5 @@ main(int argv, char **argc)\n        if (buffer)\n                free(buffer);\n\n-       exit(0);\n+       exit(exitCode);\n }</code></pre><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commitdiff;h=1c9dd6b728810ea7d2f196e6e15064017e4b9eef\">1c9dd6b728810ea7d2f196e6e15064017e4b9eef</a></p><br>\r\n<p><b>12. Улучшение документации о внутреннем представлении типа timestamp</b></p><br>\r\n<p>Документация к типу timestamp гласила:</p><br>\r\n<pre><code class=\"xml\">    When &lt;type&gt;timestamp&lt;/&gt; values are stored as eight-byte integers\n    (currently the default), microsecond precision is available over \n    the full range of values. When &lt;type&gt;timestamp&lt;/&gt; values are\n    stored as double precision floating-point numbers instead (a\n    deprecated compile-time option), the effective limit of precision\n    might be less than 6. &lt;type&gt;timestamp&lt;/type&gt; values are stored as\n    seconds before or after midnight 2000-01-01. [...]</code></pre><br>\r\n<p>В ходе работы над рассмотренным в следующем раздеде патчем было замечено, что приведенный текст создает неверное представление. На самом деле, по умолчанию timestamp хранит время в <em>микро</em>секундах. Если же пользователь выбрал устаревшее представление в виде чисел с плавающей точкой, тогда действительно время хранится в секундах.</p><br>\r\n<p>После недолгого обсуждения в рассылке вводящий в заблуждение кусок документации был переписан.</p><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=44f7afba79348883da110642d230a13003b75f62\">44f7afba79348883da110642d230a13003b75f62</a></p><br>\r\n<p><b>13. pg_filedump: частичное восстановление данных</b></p><br>\r\n<p>Этот патч был подробно рассмотрен в заметке <a href=\"https://habrahabr.ru/company/postgrespro/blog/319770/\">Пример восстановления таблиц PostgreSQL с помощью новой мега фичи pg_filedump</a>, поэтому здесь я не буду на нем подробно останавливаться. TL;DR версия — теперь при помощи pg_filedump можно восстановить по крайней мере какую-то часть данных из таблицы, даже в случае, если инстанс PostgreSQL не запускается.</p><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commitdiff;h=52fa0201f97808d518c64bcb9696f2a350678aa5\">52fa0201f97808d518c64bcb9696f2a350678aa5</a></p><br>\r\n<p><b>14. pg_filedump: декодирование каталожных таблиц</b></p><br>\r\n<p>Как и предыдущему патчу, этому была посвящена целая отельная статья <a href=\"https://habrahabr.ru/company/postgrespro/blog/323644/\">Еще одна новая фича pg_filedump: восстанавливаем каталог PostgreSQL</a>. TL;DR версия для тех, кто все равно не собирается ее читать — раньше pg_filedump не поддерживал некоторые типы, используемые в каталожных таблицах. После применения этого патча стало возможным декодировать таблицы каталога, а следовательно и восстановить схему базы данных, если она нам не известна.</p><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=pg_filedump.git;a=commitdiff;h=5c5ba458fa154183d11d43218adf1504873728fd\">5c5ba458fa154183d11d43218adf1504873728fd</a></p><br>\r\n<p><b>15а. Ускорение партицирования: исправление батлнека в find_tabstat_entry() / get_tabstat_entry()</b></p><br>\r\n<p>В PostgreSQL 10, который на момент написания этих строк разрабатывается и находится в состоянии фичфриза, была добавлена возможность <a href=\"https://commitfest.postgresql.org/12/611/\">декларативного партицирования таблиц</a>. То есть, теперь таблицу можно разбить на несколько физических таблиц по хэшу или ренджам. Это было возможно и ранее при помощи наследования таблиц, но было менее удобно и в целом выглядело как грязный хак. Примеры использования декларативного партицирования можно найти <a href=\"https://www.depesz.com/2017/02/06/waiting-for-postgresql-10-implement-table-partitioning/\">здесь</a> и <a href=\"https://www.keithf4.com/postgresql-10-built-in-partitioning/\">здесь</a>.</p><br>\r\n<p>Ну вот я и подумал, а создам-ка я побольше (скажем, 10 000) партиций и посмотрю, где будет тормозить. Теме профилирования кода на C/C++ ранее я <a href=\"http://eax.me/c-cpp-profiling/\">посвящал целую статью</a>, даже несколько, если считать статьи про <a href=\"http://eax.me/dtrace/\">DTrace</a>, <a href=\"http://eax.me/systemtap/\">SystemTap</a> и <a href=\"http://eax.me/heaptrack/\">HeapTrack</a>. Кроме того, на эту тему я делал <a href=\"http://www.highload.ru/2016/abstracts/2356.html\">доклад на HighLoad++ 2016</a>, видеозапись которого <a href=\"https://www.youtube.com/watch?v=0NU07havVD0\">лежит на YouTube</a>. Поэтому на описании процесса здесь я подробно останавливаться не буду. Скажу только, что perf top показал два явных батлнека, которые вы можете видеть на иллюстрации в начале данной статьи.</p><br>\r\n<p>Так вот, патч исправляет первый из этих батлнеков. Оказалось, что статистика по таблицам использует небольшой аллокатор памяти, построенный на списках. Поиск по идентификатору таблицы структуры PgStat_TableStatus, соответствующей таблице, производился путем сканирования этого списка, что работает <em>не очень хорошо</em>, когда таблиц 10 000. Добавление хэш-таблицы, отображающей идентификатор таблицы в указатель на структуру, моментально устранило батлнек.</p><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=090010f2ec9b1f9ac1124dc628b89586f911b641\">090010f2ec9b1f9ac1124dc628b89586f911b641</a></p><br>\r\n<p><b>15б. Ускорение партицирования: исправление батлнека в find_all_inheritors()</b></p><br>\r\n<p>Аналогичная проблема присутствовала и в процедуре рекурсивного поиска всех наследников заданной таблицы. Немногие знают, что <a href=\"https://www.postgresql.org/docs/current/static/ddl-inherit.html\">PostgreSQL поддерживает множественное наследование таблиц</a>. Поэтому при обходе дочерних таблиц процедура проходит по списку ранее посещенных таблиц. Если очередной таблицы в списке нет, она в него добавляется. Если она там уже есть, у таблицы увеличивается счетчик родителей. Список всех дочерних таблиц и число их родителей возвращается из процедуры в качестве результата.</p><br>\r\n<p>Как вы уже могли догадаться, батлнек снова был устранен добавлением хэш-таблицы для ускорения поиска по списку. По моим бенчмаркам два патча суммарно ускорили декларативное партицирование на 64%. Интересно, что патчи ускоряют его не только при большом количестве партиций, но и когда партиций всего лишь несколько штук. Хотя в последнем случае, конечно же, эффект не так заметен. </p><br>\r\n<p>Патч: <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=827d6f977940952ebef4bd21fb0f97be4e20c0c4\">827d6f977940952ebef4bd21fb0f97be4e20c0c4</a></p><br>\r\n<p><b>Заключение</b></p><br>\r\n<p>Как и ранее, цель всех этих статей — показать, что в разработке РСУБД, в частности PostgreSQL, несмотря на крайнюю интересность процесса, нет чего-то волшебного или прямо-таки непостижимо сложного. Хочется надеяться, что эта серия статей сможет мотивировать пару-тройку человек принять участие в разработке PostgreSQL, в качестве хобби, или же профессионально.</p><br>\r\n<p>В частности, компания Postgres Professional, в которой я сейчас работаю, <a href=\"https://postgrespro.ru/jobs\">перманентно нанимает</a>, притом, не только программистов, но и, к примеру, QA и DBA. Как уже было отмечено, качественные тестирование и code review в нашем деле зачастую оказываются важнее написания кода.</p></div>"]},
{"Что нового в PostgreSQL 11: JSONB-трансформы": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/webt/e7/5c/sk/e75csk69u0f_aymdeeopysub2bk.jpeg\"><br>\r\n<br>\r\nВ предыдущих постах вы могли прочитать про <a href=\"https://habr.com/company/postgrespro/blog/353126/\">INCLUDE-индексы</a> и <a href=\"https://habr.com/company/postgrespro/blog/353848/\">встроенный веб-поиск</a>. Эти фичи появятся в PostgreSQL 11, релиз которого, напомню, планируется в октябре. Сегодня мне хотелось бы продолжить обзор новых фичей грядущего релиза, рассказав про <b>JSONB-трансформы</b> для языков PL/Python (<a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=3f44e3db72ad4097aae078c075a9b3cb3d6b761b;hp=a437551a228a5099c305d1376188d6926c043724\">3f44e3db</a>) и PL/Perl (<a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=341e1661805879db958dde0a9ed1dc44b1bb10c3;hp=a08dc711952081d63577fc182fcf955958f70add\">341e1661</a>). Оба патча написаны Антоном Быковым. <br>\r\n<a name=\"habracut\"></a><br>\r\nКак вам может быть известно, PostgreSQL позволяет писать хранимые процедуры на разных языках, в том числе <a href=\"https://eax.me/postgresql-extensions/\">на C</a>, <a href=\"https://eax.me/plpgsql/\">PL/pgSQL</a>, PL/Perl, PL/Python и других. Также PostgreSQL позволяет хранить JSON, строить по нему индексы и производить различные манипуляции с документами. Для хранения документов есть два встроенных типа: JSON, являющийся по сути обычной строкой, и JSONB, реализующий более эффективное бинарное представление.<br>\r\n<br>\r\nОднако на границе этих механизмов есть небольшой косяк. Проще всего объяснить его на примере:<br>\r\n<br>\r\n<pre><code class=\"sql\">-- Важно! Синтаксис `create language` задепрекейчен с 9.1\ncreate extension plpython3u;\n\nCREATE OR REPLACE FUNCTION foo(val jsonb) RETURNS int\nLANGUAGE plpython3u\nAS $$\nassert(isinstance(val, str))\nreturn len(val)\n$$;\n\nselect foo('{\"aaa\":123, \"ййй\":456}' :: jsonb);\n</code></pre><br>\r\nВ результате код выполнится без ошибок и вернет результат 24. То есть, при передаче в хранимую процедуру JSONB был в закодирован в строку, от которой мы вычислили длину.<br>\r\n<br>\r\n<b>Fun fact!</b> На самом деле, длина исходного документа — 22 символа, а у нас почему-то получилось 24. Как ни странно, никакого бага здесь нет, как можно было бы предположить. Попробуйте в качестве домашнего задания выяснить, чем вызвано такое несоответствие.<br>\r\n<br>\r\nТак вот, но ведь мы хотели передать документ, а не строку. Само собой разумеется, строку можно декодировать обратно:<br>\r\n<br>\r\n<pre><code class=\"sql\">CREATE OR REPLACE FUNCTION bar(val_str jsonb) RETURNS int\nLANGUAGE plpython3u\nAS $$\nimport json\nval = json.loads(val_str)\nassert(isinstance(val, dict))\nplpy.info(sorted(val.items()))\nreturn len(val)\n$$;\n\nselect bar('{\"aaa\": 123, \"ййй\": 456}' :: jsonb);\n</code></pre><br>\r\nРезультат:<br>\r\n<br>\r\n<code>INFO: [('aaa', 123), ('ййй', 456)]<br>\r\n bar <br>\r\n-----<br>\r\n 2<br>\r\n(1 row)<br>\r\n</code><br>\r\n<br>\r\nВроде, похоже на правду. Но если подумать, мы тут делаем много бесполезной работы — сначала кодируем документ, а затем тут же декодируем. Если документ большой, а хранимая процедура вызывается часто, накладные расходы на это кодирование-декодирование могут быть довольно большими.<br>\r\n<br>\r\nСпрашивается, а нельзя ли просто передать JSONB в Python или Perl в виде понятных им объектов (массивов, словарей/хэшей, и так далее)? Оказывается, что можно, и названные патчи делают именно это. Вот как этим примерно пользоваться:<br>\r\n<br>\r\n<pre><code class=\"sql\">create extension jsonb_plpython3u;\n\nCREATE OR REPLACE FUNCTION baz(val jsonb) RETURNS int\nLANGUAGE plpython3u\nTRANSFORM FOR TYPE jsonb\nAS $$\nassert isinstance(val, dict)\nplpy.info(sorted(val.items()))\nreturn len(val)\n$$;\n</code></pre><br>\r\nКстати, в обратную сторону, то есть, кодировать возвращаемые документы, тоже можно:<br>\r\n<br>\r\n<pre><code class=\"sql\">CREATE OR REPLACE FUNCTION qux(val int) RETURNS jsonb\nLANGUAGE plpython3u\nTRANSFORM FOR TYPE jsonb\nAS $$\nobj = { \"val\": val }\nreturn obj\n$$;\n</code></pre><br>\r\nДля Perl и Python 2 все делается аналогично, поэтому соответствующий код я не привожу. Кроме того, не стану грузить вас тонкостями работы кода в различных граничных случаях, например, что происходит, если в возвращаемом документе встретятся комплесные числа, NaN, ±Inf, и вот это вот все. Заинтересованных читателей я призываю ознакомиться с кодом патчей. Они обильно обмазаны тестами, как раз проверяющими подобные граничные случаи.<br>\r\n<br>\r\nТакая вот интересная фича. Конечно, ситуации, в которых она оказывается полезна, возникают не часто. Но знать про существование JSONB-трансформов, все же, не повредит.</div>"]},
{"Что нового в PostgreSQL 11: INCLUDE-индексы": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/getpro/habr/post_images/04c/702/81a/04c70281a6745f83e911db28b807657f.jpg\" alt=\"image\"><br>\r\n<br>\r\nРелиз PostgreSQL 11 состоится еще не скоро, только в октябре. Но фичфриз уже наступил, а значит мы знаем, какие фичи попали в этот релиз, и можем их потестировать, <a href=\"https://eax.me/postgresql-build/\">собрав PostgreSQL</a> из ветки master. Особого внимания заслуживает фича под названием <b>INCLUDE-индексы</b>. <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=8224de4f42ccf98e08db07b43d52fed72f962ebb\">Патч</a> изначально написан <a href=\"https://habrahabr.ru/users/lubennikovaav/\">Анастасией Лубенниковой</a>, а потом допилен <a href=\"https://habrahabr.ru/users/smagen/\">Александром Коротковым</a> и <a href=\"http://sigaev.ru/\">Федором Сигаевым</a>. Протолкнуть его в PostgreSQL заняло «всего лишь» что-то около трех лет. <br>\r\n<a name=\"habracut\"></a><br>\r\nДавайте попробуем разобраться, что же это за индексы за такие. Для начала создадим табличку для опытов:<br>\r\n<br>\r\n<pre><code class=\"sql\">create table test (k serial primary key, v text, ts timestamp);\ninsert into test (v, ts) select 'key_' || s , now() from generate_series(1, 10000) as s;\n</code></pre><br>\r\n… и построим по ней обычный btree-индекс:<br>\r\n<br>\r\n<pre><code class=\"sql\">create index on test (v);\n</code></pre><br>\r\nВзглянем на план выполнения следующего запроса:<br>\r\n<br>\r\n<pre><code>=# explain select v, ts from test where v &gt; 'key_1337' and v &lt; 'key_2337';\n                                 QUERY PLAN                                  \n-----------------------------------------------------------------------------\n Bitmap Heap Scan on test  (cost=31.57..112.09 rows=1101 width=16)\n   Recheck Cond: ((v &gt; 'key_1337'::text) AND (v &lt; 'key_2337'::text))\n   -&gt;  Bitmap Index Scan on test_v_idx  (cost=0.00..31.29 rows=1101 width=0)\n         Index Cond: ((v &gt; 'key_1337'::text) AND (v &lt; 'key_2337'::text))\n(4 rows)\n</code></pre><br>\r\nСмотрите, что происходит. Поскольку индекс построен по колонке v, а в запросе мы выбираем v и ts, PostgreSQL вынужден выполнять запрос в два шага. Сначала он идет по индексу и находит строки, удовлетворяющие условию. Затем ему приходится сходить в таблицу для получения ts.<br>\r\n<br>\r\nИдея INCLUDE-индексов заключается в том, чтобы включить все необходимые для выполнения запроса данные прямо в индекс (но не индексировать их). Таким образом, запрос становится возможно выполнить за один index scan.<br>\r\n<br>\r\nДавайте проверим:<br>\r\n<br>\r\n<pre><code class=\"sql\">drop index test_v_idx;\ncreate index on test (v) include (ts);\nexplain select v, ts from test where v &gt; 'key_1337' and v &lt; 'key_2337';\n</code></pre><br>\r\nРезультат:<br>\r\n<br>\r\n<pre><code> Index Only Scan using test_v_ts_idx on test  (cost=0.29..46.30 rows=1101 width=16)\n   Index Cond: ((v &gt; 'key_1337'::text) AND (v &lt; 'key_2337'::text))\n(2 rows)\n</code></pre><br>\r\nЗа счет того, что теперь мы не ходим в таблицу, запрос должен работать быстрее. Стоит однако отметить, что на практике все зависит от ваших данных. Каждый случай уникален, поэтому я сознательно не привожу здесь каких-то <a href=\"https://eax.me/benchmarks/\">синтетических бенчмарков</a>. Может оказаться, что на ваших объемах данных index only scan с include-индексами работает так же быстро, как и в случае с обычными индексами. А то и вовсе накопленная статистика говорит PostgreSQL, что запрос быстрее сделать heap scan'ом. Такое может произойти, например, если селективность вашего запроса низка.<br>\r\n<br>\r\nТак или иначе, знать про эту возможность полезно, и я искренне рад, что она появится в PostgreSQL 11.</div>"]},
{"PGCon 2018: фотографии, слайды, впечатления": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/webt/of/ad/uh/ofaduhah-wae4g-zanfzrkyxekq.jpeg\"><br>\r\n<br>\r\nНа прошлой неделе, с 29 мая по 1 июня, состоялась <a href=\"http://www.pgcon.org/2018/\">конференция PGCon 2018</a>. PGCon проходит в Оттаве каждый год. В отличие от других конференций, посвященных PostgreSQL, PGCon позиционируется, как конференция не пользователей, а <i>разработчиков</i>. Это делает ее крайне важным событием в жизни проекта. Далее я хотел бы поделиться своими впечатлениями от конференции и рассказать о наиболее запомнившихся мне моментах. <a name=\"habracut\"></a><br>\r\n<br>\r\nОт <a href=\"https://postgrespro.ru/\">нашей компании</a> на конференции присутствовало четыре человека: <a href=\"http://akorotkov.github.io/\">Александр Коротков</a>, <a href=\"http://sigaev.ru/\">Федор Сигаев</a>, <a href=\"https://habr.com/users/lubennikovaav/\">Анастасия Лубенникова</a> и ваш покорный слуга, <a href=\"https://eax.me/\">Александр Алексеев</a>. Все мы выступили с докладами, некоторые даже с несколькими.<br>\r\n<br>\r\nАлександр Коротков выступил с докладом <a href=\"https://www.pgcon.org/2018/schedule/events/1223.en.html\">Credereum — blockchain-enabled Postgres</a>. Также Александр принимал активное участие в <a href=\"https://wiki.postgresql.org/wiki/PgCon_2018_Developer_Unconference\">Unconference</a>. Что такое Unconference? В течение одного дня разработчики общаются на любые темы, которые они посчитают важными и за которые проголосуют другие разработчики. С помощью маркеров, больших желтых стикеров и поднятия рук составляется расписание, затем разработчики ходят на собрания, посвященные интересующим их темам.<br>\r\n<br>\r\n<img src=\"https://habrastorage.org/webt/wv/q7/ri/wvq7risfl9r0ucnrbteymp2y0ly.jpeg\"><br>\r\n<em>Александр Коротков (ближе всех к доске) и <a href=\"https://rhaas.blogspot.com/\">Роберт Хаас</a> (по правую руку от него) обсуждают с аудиторией добавление в PostgreSQL плагабл стораджей.</em><br>\r\n<br>\r\nВсего Александр принимал участие в ведении двух секций на Unconference — «Scale Out &amp; Global snapshots» и «Plugable Table Access Methods». Добавление в PostgreSQL глобальных снапшотов позволит выполнять распределенные транзакции между несколькими инстансами СУБД с сохранением свойств ACID, что в настоящее время сделать непросто. Что же до плагабл стораджей, с их помощью можно будет реализовать колоночное хранилище, in-memory таблицы, index organized tables и другие интересные фичи. Как глобальные снапшоты, так и плагабл стораджи на момент написания этих строк находятся в разработке.<br>\r\n<br>\r\nДоклад Федора назывался <a href=\"https://www.pgcon.org/2018/schedule/events/1169.en.html\">Jsonb flexible indexing</a>. Также Федор имел честь быть приглашенным на закрытый Developer Meeting. Несмотря на закрытость данного собрания, оно <a href=\"https://wiki.postgresql.org/wiki/PgCon_2018_Developer_Meeting\">законспектировано на вики-сайта проекта</a>. Из конспекта мы можем узнать, что в рамках Developer Meeting обсуждался график коммитфестов PostgreSQL 12, как сделать так, чтобы патчи меньше переносились с одного коммитфейса на другой, как GDPR затрагивает проект, и другие вопросы.<br>\r\n<br>\r\n<img src=\"https://habrastorage.org/webt/j0/u_/wf/j0u_wfcv3bklezamk5qtaap6l9y.jpeg\"><br>\r\n<i>Участники Developer Meeting. Федор стоит по центру в первом ряду, в желтой футболке.</i><br>\r\n<br>\r\nАнастасия и я выступили с совместным докладом <a href=\"https://www.pgcon.org/2018/schedule/events/1147.en.html\">Growing up new PostgreSQL developers</a>. Доклад этот совершенно не технический. Он рассказывает о том, как мы искали новых разработчиков в нашу компанию, вели курсы в ВМК и в ВШЭ, как собрали все грабли начинающих менеджеров проектов, и подобным вопросам. Слайды доклада я <a href=\"https://afiskon.github.io/pgcon2018.html\">выложил</a> в своем англоязычном блоге для <a href=\"https://planet.postgresql.org/\">PostgreSQL Planet</a>.<br>\r\n<br>\r\nТакже у Анастасии был второй доклад, <a href=\"https://www.pgcon.org/2018/schedule/events/1194.en.html\">Towards scalable ACID PostgreSQL with partitioning, postgres_fdw and logical replication</a>. Этот доклад изначально подал наш коллега, Арсений Шер. К сожалению, Арсений не смог в этот раз посетить конференцию, и доклад за него рассказывала Анастасия. Из доклада вы узнаете о том, как работает и в каком направлении развиваются наши реализации шарднга и master-master репликации, являющиеся частью PostgresPro Enterprise.<br>\r\n<br>\r\nНа церемонии закрытия конференции нас ждал приятный сюрприз. Александр Коротков оказался среди немногих людей, которым было решено предоставить права коммитера. Помимо Александра коммитерами <a href=\"https://www.postgresql.org/message-id/8953.1527887111%40sss.pgh.pa.us\">стали</a> Etsuro Fujita, Peter Geoghegan, Amit Kapila, Thomas Munro, Michael Paquier и Tomas Vondra. Всего же в России сейчас есть два коммитера — Александр и Федор, оба работают в PostgresPro.<br>\r\n<br>\r\nЭто что касается наиболее запомнившихся мне событий и вклада непосредственно нашей компании в конференцию. К сожалению, в рамках одного поста не представляется возможным подробно рассказать обо всем, что происходило на конференции, да еще и так, чтобы это не превратилось в скучный лонгрид. Поэтому на этом моменте я, пожалуй, начну сворачивать свое повествование. (И вообще, мы-то с вами понимаем, что доклады — это только предлог чтобы собраться, а все самое интересное происходило в кулуарах и на social events.)<br>\r\n<br>\r\nPGCon — совершенно топовая конференция, и я рекомендую вам посетить ее в следующем году, не пожалеете. Где еще в одном месте собирается столько талантливых людей (поговорить с которыми можно не только за Постгрес, а вообще о чем угодно, начиная от электроники и заканчивая программированием на Clojure) и можно в живую наблюдать работу такого уникального open source сообщества, как сообщества PostgreSQL?</div>"]},
{"Что нового в PostgreSQL 11: улучшения в кастинге": ["<div class=\"post__text post__text-html js-mediator-article\"><img src=\"https://habrastorage.org/webt/lj/bg/jd/ljbgjdz1r4gal9_fcbm0mbzlqqm.jpeg\"><br>\r\n<br>\r\nПродолжая тему новый возможностей грядущего релиза PostgreSQL 11 (предыдущие посты: <a href=\"https://habr.com/company/postgrespro/blog/353126/\">раз</a>, <a href=\"https://habr.com/company/postgrespro/blog/353848/\">два</a>, <a href=\"https://habr.com/company/postgrespro/blog/354264/\">три</a>), я хотел бы рассказать об одном небольшом, но важном изменении. Изменение это касается кастинга одних типов в другие. И, конечно же, оно касается JSONB, потому что в PostgresPro мы его очень любим! <a name=\"habracut\"></a><br>\r\n<br>\r\nРечь идет о <a href=\"https://git.postgresql.org/gitweb/?p=postgresql.git;a=commitdiff;h=c0cbe00fee6d0a5e0ec72c6d68a035e674edc4cc\">патче c0cbe00f</a>:<br>\r\n<br>\r\n<code>commit c0cbe00fee6d0a5e0ec72c6d68a035e674edc4cc<br>\r\nAuthor: Teodor Sigaev &lt;teodor@sigaev.ru&gt;<br>\r\nDate: Thu Mar 29 16:33:56 2018 +0300<br>\r\n<br>\r\nAdd casts from jsonb<br>\r\n <br>\r\n Add explicit cast from scalar jsonb to all numeric and bool types. It would be<br>\r\n better to have cast from scalar jsonb to text too but there is already a cast<br>\r\n from jsonb to text as just text representation of json. There is no way to have<br>\r\n two different casts for the same type's pair.<br>\r\n <br>\r\n Bump catalog version<br>\r\n <br>\r\n Author: Anastasia Lubennikova with editorization by Nikita Glukhov and me<br>\r\n Review by: Aleksander Alekseev, Nikita Glukhov, Darafei Praliaskouski<br>\r\n Discussion: https://www.postgresql.org/message-id/flat/0154d35a-24ae-f063-5273-9ffcdf1c7f2e@postgrespro.ru<br>\r\n</code><br>\r\n<br>\r\nСуть проблемы заключается вот в чем. Если вы возьмете PostgreSQL 10, то обнаружите следующее поведение:<br>\r\n<br>\r\n<code>=# select 'true' :: jsonb :: bool;<br>\r\nERROR: cannot cast type jsonb to boolean<br>\r\nLINE 1: select 'true' :: jsonb :: bool;<br>\r\n<br>\r\n=# select '12345' :: jsonb :: int4;<br>\r\nERROR: cannot cast type jsonb to integer<br>\r\nLINE 1: select '12345' :: jsonb :: int4;<br>\r\n<br>\r\n=# select '12345.67' :: jsonb :: float8;<br>\r\nERROR: cannot cast type jsonb to double precision<br>\r\nLINE 1: select '12345.67' :: jsonb :: float8;<br>\r\n</code><br>\r\n<br>\r\nТо есть, JSONB не приводится к числовым типам и boolean. Конечно, не то чтобы это было прямо очень большой проблемой. В конце концов, всегда можно кастонуть через text:<br>\r\n<br>\r\n<code>=# select '12345.67' :: jsonb :: text :: float8;<br>\r\n float8 <br>\r\n----------<br>\r\n 12345.67<br>\r\n</code><br>\r\n<br>\r\nТем не менее, такое решение выглядит как-то костыльно, да и по поводу его производительности есть вопросы.<br>\r\n<br>\r\nТеперь взглянем на поведение ветки master:<br>\r\n<br>\r\n<code>=# select 'true' :: jsonb :: bool;<br>\r\n bool <br>\r\n------<br>\r\n t<br>\r\n<br>\r\n=# select '12345' :: jsonb :: int4;<br>\r\n int4 <br>\r\n-------<br>\r\n 12345<br>\r\n<br>\r\n=# select '12345.67' :: jsonb :: float8;<br>\r\n float8 <br>\r\n----------<br>\r\n 12345.67<br>\r\n</code><br>\r\n<br>\r\nКак видите, теперь можно кастовать JSONB в boolean и числовые типы. Ура!<br>\r\n<br>\r\nХарактерно, что кастинг в обратную сторону пока что возможен только через промежуточный кастинг в text:<br>\r\n<br>\r\n<code>=# select 12345.67 :: jsonb;<br>\r\nERROR: cannot cast type numeric to jsonb<br>\r\nLINE 1: select 12345.67 :: jsonb;<br>\r\n<br>\r\n=# select 12345.67 :: text :: jsonb;<br>\r\n jsonb <br>\r\n----------<br>\r\n 12345.67<br>\r\n(1 row)<br>\r\n</code><br>\r\n<br>\r\nВы спросите, а почему нет прямого кастинга? Думаю, просто еще ни у кого не дошли руки его дописать. Звучит, как <a href=\"https://habr.com/company/postgrespro/blog/308442/\">возможность для самореализации</a>, не находите? ;)</div>"]},
{"Три серьезные уязвимости во FreeBSD": ["<div class=\"post__text post__text-html js-mediator-article\">На security.freebsd.org появилась информация о трех серьезных уязвимостях во FreeBSD.<br>\r\n<a name=\"habracut\"></a><br>\r\n<ul>\r\n<li><b>Уязвимость в named</b>. При запросе клиентом DNSSEC записи с CD (Checking Disabled) флагом, сервер может кэшировать непроверенные данные. Они могут быть посланы другому клиенту, даже если он не установил CD флаг.<br>\r\n<br>\r\nУязвимы все поддерживаемые ветки FreeBSD. Подробности — <a href=\"http://security.freebsd.org/advisories/FreeBSD-SA-10:01.bind.asc\">FreeBSD-SA-10:01.bind</a></li>\r\n<li><b>Уязвимость в ntpd</b>. При получении запроса MODE_PRIVATE (mode 7) или error-response от узла, не указанного в секциях restrict...noquery и restrict...ignore, соответствующая запись будет создана в лог-файле и даже послан ответ на error-response.<br>\r\n<br>\r\nЗлоумышленник может послать error-response с поддельным ip отправителя (например, с ip самого уязвимого ntpd сервера или второго также уязвимого ntpd сервера). Как следствие, сервер будет до бесконечности слать пакеты с error-response, замедляя работу сети, съедая ресурсы процессора, и свободное место на жестком диске, что рано или поздно приведет к DoS.<br>\r\n<br>\r\nУязвимы все поддерживаемые ветки FreeBSD. Подробности — <a href=\"http://security.freebsd.org/advisories/FreeBSD-SA-10:02.ntpd.asc\">FreeBSD-SA-10:02.ntpd</a></li>\r\n<li><b>Уязвимость в ZFS ZIL</b>. ZFS Intent Log («ZIL») — это механизм, позволяющий отложить операции записи на жесткий диск, производя их лишь в ОЗУ. В случае какого-либо сбоя (например, отключения питания), производится анализ intent-log-файла и на жесткий диск дописываются данные, потерянные в результате сбоя.<br>\r\n<br>\r\nУязвимость заключается в следующем. Если setattr транзакция не будет завершена из-за отключения питания или иного сбоя, при анализе log-файла вместо указанных в транзакции прав доступа будут выставлены 07777. Это может привести к повышению привилегий или чтению/изменению произвольного файла.<br>\r\n<br>\r\nУязвимость присутствует во FreeBSD &gt;= 7.0. Подробности — <a href=\"http://security.freebsd.org/advisories/FreeBSD-SA-10:03.zfs.asc\">FreeBSD-SA-10:03.zfs</a></li>\r\n</ul><br>\r\n<br>\r\nДля устранения уязвимостей предлагается обновиться до последней версии вашей ветки или применить патчи (подробности — по приведенным выше ссылкам). Разумеется, если вы не пользуетесь zfs, у вас не запущены named и ntpd, с обновлением можно не торопиться.</div>"]},
{"Mini-FAQ по Perl (Частые вопросы, ЧаВо)": ["<div class=\"post__text post__text-html js-mediator-article\">Меня часто спрашивают, как я учил Perl — какие книги читал, какие сайты посещал и так далее. Многие считают, что Perl имеет сложный синтаксис, и потому не хотят или бояться его учить. В этом FAQ я хотел бы поделиться своим мнением относительно языка Perl. <a name=\"habracut\"></a><br>\r\n<br>\r\n<strong>Я слышал, что Perl — устаревший язык и сейчас на нем никто не пишет. Так ли это?</strong><br>\r\nНет, не так. Perl используется системными администраторами (или просто продвинутыми пользователями) для автоматизации рутинной работы. Perl используется для создания веб-сайтов. Также на нем создаются обычные приложения, как и на любом другом языке программирования.<br>\r\n<br>\r\nОтносительно возраста языка — Perl был создан в 1986 году и с тех пор активно развивался и изменялся. В настоящее время Perl поддерживает модульное и объектно-ориентированное программирование, регулярные выражения и т.д. — в общем, идет в ногу со временем.<br>\r\n<br>\r\nОбъявления о имеющейся вакансии Perl-программиста появляются с большой частотой, при этом уровень заработной платы, как правило, ощутимо выше, чем у программистов на Си или Java. Впрочем, к моменту, когда вы будете читать эти строки, ситуация могла и измениться, так что лучше проведите собственное исследование в этом направлении, посетив, к примеру, rabota.ru.<br>\r\n<br>\r\n<strong>Чем хорош Perl?</strong><br>\r\nЯ бы выделил следующие преимущества Perl перед другими языками программирования:<br>\r\n<ul>\r\n<li>Программы, написанные на Perl (как и в случае с любым другим скриптовым языком), одинаково хорошо работают под разными операционными системами.</li>\r\n<li>Зачастую то, что на другом языке программирования (например, PHP) занимает десять строк кода может быть написано на Perl в одну строчку.</li>\r\n<li>Если перед вами стоит какая-то задача, загляните в CPAN. Скорее всего, кто-то уже решил ее. Вам остается лишь скачать модуль и прочитать документацию к нему.</li>\r\n</ul><br>\r\n<br>\r\n<strong>Я слышал, что синтаксис Perl неописуемо сложен. Так ли это?</strong><br>\r\nСинтаксис Perl очень похож на синтаксис Java или PHP. Те же циклы, те же условные операторы и фигурные скобочки. Репутацию языка со сложным синтаксисом Perl совершенно незаслуженно получил за имеющиеся в нем операторы, которые, как уже отмечалось, позволяют писать более короткий код. Скажем, вы можете объявить массив слов так:<br>\r\n<br>\r\n<code>my @arr = (\"aaa\", \"bbb\", \"ccc\");</code><br>\r\n<br>\r\nили более простым способом — без запятых и кавычек:<br>\r\n<br>\r\n<code>my @arr = qw/aaa bbb ccc/;</code><br>\r\n<br>\r\nЕсли вас интересуют конкретные примеры, в которых код на Perl оказывается короче, чем на каком-нибудь PHP, я позволю себе отослать вас к моему блогу, а точнее — к записи <a href=\"http://eax.me/perl-hacks/\">Интересные примеры на Perl</a>. Особое внимание обратите на операторы grep и sort, подумайте, сколько кода занял бы аналогичный код на PHP.<br>\r\n<br>\r\n<strong>С чего начать изучение Perl?</strong><br>\r\nЛично я учился на примерах. Вообще считаю этот способ самым простым и понятным. Вы можете без труда найти их в Google или в уже упомянутом моем блоге — в нем я часто выкладываю скрипты с комментариями.<br>\r\n<br>\r\nТем не менее могу порекомендовать несколько хороших книг — это «Изучаем Perl» и «Perl: изучаем глубже», авторы — Шварц Р. и Феникс Т. Недавно эти книги были переизданы, так что в них вы найдете самый легкую для усвоения и актуальную информацию о программировании на Perl. Настоятельно <strong>не</strong> рекомендую брать какие-либо другие книги, поскольку написанное в них зачастую уже давно потеряло актуальность (если книжка, скажем 2006-го года — помните, что Perl активно развивается) или в ней написано 1000 страниц ни о чем.<br>\r\n<br>\r\nЕсли у вас возникнут вопросы относительно программирования на Perl, вы можете попросить совета на программерских форумах (например, vingrad.ru) или в жж-сообществе ru_perl.<br>\r\n<br>\r\n<strong>Я не хочу устанавливать UNIX только ради этого вашего Perl!</strong><br>\r\nИ не надо — Perl портирован под Windows. Соответствующий проект называется ActivePerl. Просто скачайте и установите ActivePerl с <a href=\"http://www.activestate.com/activeperl/\">http://www.activestate.com/activeperl/</a> и пользуйтесь на здоровье. Никаких кряков и кейгенов искать не нужно — программа бесплатная.<br>\r\n<br>\r\n<strong>Уж больно все хорошо и замечательно. А как же ложка дегтя?</strong><br>\r\nДа, пожалуй она имеется, и даже не одна.<br>\r\n<br>\r\nВо-первых, в любом языке работает так называемый закон «водяного матраца». Если вкратце, он означает что язык может быть либо простым в изучении, но программы на нем будут состоять из большого числа строк (как в случае с PHP), либо сложным в изучении, но позволяющем писать меньше кода (это как раз наш случай).<br>\r\n<br>\r\nВо-вторых, Perl подходит не для всяких задач. Если от вас требуется написать программу, которая должна работать быстро (графический редактор, 3D игру), Perl вам не подойдет. Как и любой другой скриптовый язык. Аналогично я не стал бы писать на Perl драйверы.<br>\r\n<br>\r\nВ-третьих, хоть Perl на мой взгляд и не сложен в изучении, но оно, это самое изучение, занимает больше времени, чем в случае с другим языком. Для сравнения, PHP я освоил буквально за пару ночей — переменные, циклы, классы — тут знать то нечего. Начать писать на Perl можно за тот же промежуток времени, но чтобы хорошо в нем разобраться, мне лично потребовалось несколько месяцев.<br>\r\n<br>\r\n<strong>А минус за ненависть к PHP не желаете?</strong><br>\r\nPHP имеет свои преимущества, многие из которых вытекают из простоты его синтаксиса. Простой синтаксис, значит прост в изучении. Прост в изучении, значит больше комьюнити.<br>\r\n<br>\r\nНе стоит недооценивать PHP, ведь благодаря ему появились такие мощные CMS, как Drupal и Joomla. Аналогичных проектов на Perl мне не известно, если не считать аналога WordPress — Movable Type. Последний, к слову, пользуется большой популярностью за рубежом.<br>\r\n<br>\r\n<b>Update:</b> я тут написал небольшой пост об основах программирования на Perl, может быть кому-нибудь пригодится: <a href=\"http://eax.me/perl-basics/\">http://eax.me/perl-basics/</a></div>"]}
]